
//constant values should be in place evaluated by parser by calling the interpreter
//the ISP stores now also the value in case of const expressions
//the code genereator should modify addresses for const variables such
//that the interpreter during parsing can get the right values.

//todo ptr=ptr+1 should not use addint

//KSVM Virtual Machine for fast execution
//And c99 compatible compiler into KSVM mnemonic
//Copyright 4.9.2012 by Kilian Singer
//email@kilian-singer.de
//All rights reserved.

//todo
//error reporting should correct for expecting ... errors
//and ignore unknown identifier errors.

//datastructure: we have a permanent tag on ISP
//if marked amount structure is memorized in permanentISP
//then upon pop the structure is kept on stack
//and when other elements are pushed structure is first relocated and then new element is pushed
//this compactifies the permanent data until upon empty stack
//all elements are compressed on stackend
//pointers to permanent objects are valid until we increment isp beyond the permanent obj
//then valid pointers can only obtained when fully compressed stack is kept
//if pointer is needed after compression we store the value of permanentISP which is a virtual isp decremented and incremented only for permanent object
//then after all unpermanent elements are removed we have fully valid pointers
//this can be used for all strings for debug
//but also for future char s[] and array initializers.

//we should store strings on ISP with size last and string first and alignement, but the pointer in hashmap is on the string.
//also avoid double storage in identifier2string by looking in hashmap and reusing the string. do not use local var strings for global vars and function (this should not happen due to design anyways). if it is not hashmap we store the pointer to the string in i->identifier; such that upon inserting hash we can use this pointer. then we should null i->identifier.
//when we delete a hash we should only delete string when ISP is > than stringadr which is always the case due to design.
//so when ISP is increased (stack emptied) we have to watch for string size stuff to properly decrement stack.
//Problem is when we use many identifiers, like in function definition, thereis functionname and params then this tempstring thing fails!
//DEBUG mode must permanently store strings! no idea how to do this
//also shifting the strings is a problem in debug mode
//forward def: we have to store calls to forward functions on stack ISP and also make a hash entry such as(FORWARD$$) Then on stack cleanup we have to start from IBP until last ISP and if we have a forward def we have to put it right after the function adress on stack. When everything is finished we go through the FORWARD$$ hash list and correct the adresses.
//break continue here we also store it on stack ISP if we do not know adress yet. Then on stack cleanup of for loop or while do loop we can correct adresses
//struct
//fnptr
//error:
//int a;
//a(3)// is not detected
//
//todo for a++ and 8++ findout when we have ltype and rtype
//todo int i;float i; does not cause error

//also we have to put on ILBP the current break and continue jump positions and all break and continue commands such that on END we can adjust the jump positions
// gcc -m32 logic.c if you want 32bit mode in linux
//#include "stdafx.h" we use precompiled headers with Fi force include option

#include <string.h>//for memset
#include <stdio.h>//printf sprintf getchar
#include <math.h>
#ifdef _DEBUG
#define DODEBUG
#endif
#ifndef DODEBUG
#define printdebug
#else
#define printdebug printf
#endif 
#if defined(__LP64__) || defined(_LP64) || defined(WIN64)
#define BUILD_64   1
#endif
#ifdef BUILD_64
typedef long long ptrdiff;
#else
typedef int ptrdiff;
#endif
//return values and type
int doexecuteloop;
typedef enum Mode {kvm,printit,modes,kvm_compact} Mode;//kvm_compact not yet implemented

#define ENUM
enum OPCODE {
#include "kvm.h"
OPCODES
};
#undef ENUM

//typedef void ((*voidfn)());//type of internal functions
//typedef enum OPCODE voidfn;
typedef unsigned char voidfn;

//sizes with fillers on amd64 systems
#define SIZEOFOP sizeof(void*)//here we would like to use voidfn instead of void* but the VoidFnArr patching does not work otherwise, error occurs at init run when jumping over functions
#define SIZEOFPTR sizeof(void*)
#define SIZEOFINT sizeof(int)//amd64 uses fillers for int such that they take 64 bits but only 32 bits are used
#define SIZEOFFLOAT sizeof(float)
#define SIZEOFDOUBLE sizeof(double)
#define SIZEOFCHAR sizeof(char)//we have a problem when using 1 because of alignment
void *retvoid;
int retint;
float retfloat;
double retdouble;
char retchar;
typedef union u{
	voidfn Voidfn;
	voidfn VoidfnArr[1];
	void *PVoid;
	double Double;//works
	int Int;
	float Float;
	char *Str;//only for debugging
	char Char;
	union u *Pu;
	ptrdiff ptrd;
} u;
typedef char mem;
typedef union memptr{
	char *ptr;
	union u* Pu;
} memptr;
memptr PC;//Program Counter
#define STACKSIZE 10000
mem stack[STACKSIZE];//Stack
int sizeoflastpushed;
memptr stackend={stack+STACKSIZE};
memptr SPGLOB;//end of global stack points to last valid entry in the global SP
memptr SP;//Stackpointer
memptr BP;//Basepointer points to first stackvariable after return adress
memptr LBP;//Local basepointer for the local stack
//BIG functions can be called from interpreter
//small functions are for internal use
void printfid(char *s,int len){
	int n;
	for(n=0;n<len; n++) printf("%c",s[n]);
}
void printfid2(){
	char *s;
	int len;
	s=PC.Pu->Str;
	PC.ptr+=SIZEOFPTR;
	len=PC.Pu->Int;
	printfid(s,len);
	PC.ptr+=SIZEOFINT;
}
int ENDPROG=0;//inteans for what to do after return
int RETURN_=0;//inteans for what to do after return
int RETURN_VAL_=0;
void initinterpreter(){
	ENDPROG=0;//inteans for what to do after return
	RETURN_=0;//inteans for what to do after return
	RETURN_VAL_=0;
	doexecuteloop=1;
}
void do_ret(){//perform a return
	SP.ptr=BP.ptr;
	PC.ptr=SP.Pu->Str;
	SP.ptr+=SIZEOFPTR;
	BP.ptr=SP.Pu->Str;
	SP.ptr+=SIZEOFPTR;
}



#define FN
#include "kvm.h"
#include "printit.h"
#undef FN

#define INIT
void (*mnemonic[modes][OPCODES+1])()={{
#include "kvm.h"
0},{
#include "printit.h"
0}};
#undef INIT

int execute(){
	RETURN_VAL_=0;
	doexecuteloop=1;
	while(doexecuteloop) mnemonic[kvm][PC.Pu->Voidfn]();
	if(ENDPROG) return -1;
	return RETURN_VAL_;
}

///starting with parser
///////////////////////
//tokens
const char *Typedef="typedef";
const char *Extern="extern";
const char *Static="static";
const char *Auto="auto";
const char *Register="register";
const char *Void="void";
const char *Char="char";
const char *Short="short";
const char *Int="int";
const char *Long="long";
const char *Float="float";
const char *Double="double";
const char *Signed="signed";
const char *Unsigned="unsigned";
const char *_int="_int";
const char *_COmplex="_Complex";
const char *CBraOpen="{";//Curly Bracket Open
const char *CBraClose="}";
const char *Struct="struct";
const char *Union="union";
const char *Const="const";
const char *Restrict="restrict";
const char *Volatile="volatile";
const char *Sizeof="sizeof";
const char *Enum="enum";
const char *Inline="inline";
const char *Case="case";
const char *Default="default";
const char *If="if";
const char *Else="else";
const char *Switch="switch";
const char *While="while";
const char *Do="do";
const char *For="for";
const char *Goto="goto";
const char *Continue="continue";
const char *Break="break";
const char *Return="return";
const char *BraOpen="(";// Bracket Open
const char *BraClose=")";
const char *SBraOpen="[";//Square Bracket Open
const char *SBraClose="]";
const char *Gt=">";
const char *Lt="<";
const char *Eq="=";
const char *DotDotDot="...";
const char *GtGtEq=">>=";
const char *LtLtEq="<<=";
const char *PlusEq="+=";
const char *MinusEq="-=";
const char *MulEq="*=";
const char *DivEq="/=";
const char *ModEq="%=";
const char *AndEq="&=";
const char *XorEq="^=";
const char *OrEq="|=";
const char *GtGt=">>";
const char *LtLt="<<";
const char *PlusPlus="++";
const char *MinusMinus="--";
const char *MinusGt="->";
const char *AndAnd="&&";
const char *OrOr="||";
const char *LtEq="<=";
const char *GtEq=">=";
const char *EqEq="==";
const char *NotEq="!=";
const char *Semicolon=";";
const char *Comma=",";
const char *Colon=":";
const char *Dot=".";
const char *And="&";
const char *Not="!";
const char *Tilde="~";
const char *Minus="-";
const char *Plus="+";
const char *Mul="*";
const char *Div="/";
const char *Mod="%";
const char *Xor="^";
const char *Or="|";
const char *Question="?";
//sorted tokenlist define generatesortedtokenlist and add new elements at the end of both tokenlist and tokenliststring
const char **tokenlist0[]={&NotEq,&Not,&ModEq,&Mod,&AndAnd,&AndEq,&And,&BraOpen,&BraClose,&MulEq,&Mul,&PlusPlus,&PlusEq,&Plus,&Comma,&MinusMinus,&MinusEq,&MinusGt,&Minus,&DotDotDot,&Dot,&DivEq,&Div,&Colon,&Semicolon,&LtLtEq,&LtLt,&LtEq,&Lt,&EqEq,&Eq,&GtEq,&GtGtEq,&GtGt,&Gt,&Question,&SBraOpen,&SBraClose,&XorEq,&Xor,&_int,&_COmplex,&Auto,&Break,&Case,&Char,&Const,&Continue,&Default,&Double,&Do,&Else,&Enum,&Extern,&Float,&For,&Goto,&If,&Inline,&Int,&Long,&Register,&Restrict,&Return,&Short,&Signed,&Sizeof,&Static,&Struct,&Switch,&Typedef,&Union,&Unsigned,&Void,&Volatile,&While,&CBraOpen,&OrEq,&OrOr,&Or,&CBraClose,&Tilde};//we need to use &... because otherwise compiler complains that initializer is not constant
const char **tokenlist=(const char**)tokenlist0;
int tokenlookup[128-32];

void gentokenlookup(){
	int i,n=sizeof(tokenlist0)/sizeof(const char**);
	for(i=0;i<n;++i) tokenlist[i]=*tokenlist0[i];//we make tokenlist a pointer to c strings
	for(i=0;i<128-32;++i) tokenlookup[i]=0;
	for(i=0;i<n;++i) {
		char c=(tokenlist[i][0]-32)&127;
		if(!tokenlookup[c]) tokenlookup[c]=i;
	}
	//now tokenlookup[(c-32)&127] points to the first element in tokenlist with the same starting letter
}
//#define generatesortedtokenlist

#ifdef generatesortedtokenlist
const char *tokenliststring[]={"NotEq","Not","ModEq","Mod","AndAnd","AndEq","And","BraOpen","BraClose","MulEq","Mul","PlusPlus","PlusEq","Plus","Comma","MinusMinus","MinusEq","MinusGt","Minus","DotDotDot","Dot","DivEq","Div","Colon","Semicolon","LtLtEq","LtLt","LtEq","Lt","EqEq","Eq","GtEq","GtGtEq","GtGt","Gt","Question","SBraOpen","SBraClose","XorEq","Xor","_int","_COmplex","Auto","Break","Case","Char","Const","Continue","Default","Double","Do","Else","Enum","Extern","Float","For","Goto","If","Inline","Int","Long","Register","Restrict","Return","Short","Signed","Sizeof","Static","Struct","Switch","Typedef","Union","Unsigned","Void","Volatile","While","CBraOpen","OrEq","OrOr","Or","CBraClose","Tilde"};//we need to use ... because otherwise compiler complains that initializer is not constant
int strcmp2(const char *s1,const char *s2){
	while(1){
		int v1=*s1;
		int v2=*s2;
		if(v1==0) v1=256;
		if(v2==0) v2=256;
		if(v1>v2) return 1;
		else if(v1<v2) return -1;
		else {
			if((*s1==0) && (*s2==0)) return 0;
			else if(*s1==0) return 1;
			else if(*s2==0) return -1;
			++s1;++s2;
		}
	}
}
void sorttokenlist(){
	int i,j,n=sizeof(tokenlist0)/sizeof(const char**);
	for(i=0;i<n;++i){
		int m=i;
		const char **p=tokenlist0[i];
		const char *p2=tokenliststring[i];

		for(j=n-1;j>i;--j){
			if(strcmp2(*tokenlist0[m],*tokenlist0[j])>0) {
				m=j;
			}
		}
		tokenlist0[i]=tokenlist0[m];
		tokenlist0[m]=p;

		tokenliststring[i]=tokenliststring[m];
		tokenliststring[m]=p2;


	}
	for(i=0;i<n;++i) printf("&%s,",tokenliststring[i]);
	printf("\n");
		for(i=0;i<n;++i) printf("\"%s\",",tokenliststring[i]);
		printf("\n\n\nignore\n");
	for(i=0;i<n;++i) printf("\"%s\",",*tokenlist0[i]);
}
#endif
/*
If one alternative is an initial substring of another alternative, the longer alternative should be attempted first.
Avoid left recursion!
translation-unit:
        external-declaration
        translation-unit external-declaration
external-declaration:
        function-definition
        declaration
function-definition:
        declaration-specifiers declarator declaration-list? compound-statement
declaration-specifiers:
        storage-class-specifier declaration-specifiers?
        type-specifier declaration-specifiers?
        type-qualifier declaration-specifiers?
        function-specifier declaration-specifiers?
storage-class-specifier:
        "typedef"
        "extern"
        "static"
        "auto"
        "register"
type-specifier:
        "void"
        "char"
        "short"
        "int"
        "long"
        "float"
        "double"
        "signed"
        "unsigned"
        "_int"
        "_Complex"
        struct-or-union-specifier
        enum-specifier
        typedef-name
struct-or-union-specifier:
        struct-or-union identifier? "{" struct-declaration-list "}"
        struct-or-union identifier
struct-or-union:
        "struct"
        "union"
struct-declaration-list:
        struct-declaration
        struct-declaration-list struct-declaration
struct-declaration:
        specifier-qualifier-list struct-declarator-list ";"
specifier-qualifier-list:
        type-specifier specifier-qualifier-list?
        type-qualifier specifier-qualifier-list?
type-qualifier:
        "const"
        "restrict"
        "volatile"
struct-declarator-list:
        struct-declarator
        struct-declarator-list "," struct-declarator
struct-declarator:
        declarator
        declarator? ":" constant-expression
declarator:
        pointer? direct-declarator
pointer:
        "*" type-qualifier-list?
        "*" type-qualifier-list? pointer
type-qualifier-list:
        type-qualifier
        type-qualifier-list type-qualifier
direct-declarator:
        identifier
        "(" declarator ")"
        direct-declarator "[" type-qualifier-list? assignment-expression? "]"
        direct-declarator "[" "static" type-qualifier-list? assignment-expression "]"
        direct-declarator "[" type-qualifier-list "static" assignment-expression "]"
        direct-declarator "[" type-qualifier-list? "*" "]"
        direct-declarator "(" parameter-type-list ")"
        direct-declarator "(" identifier-list? ")"
assignment-expression:
        conditional-expression
        unary-expression assignment-operator assignment-expression
conditional-expression:
        logical-OR-expression
        logical-OR-expression "?" expression ":" conditional-expression
logical-OR-expression:
        logical-AND-expression
        logical-OR-expression "||" logical-AND-expression
logical-AND-expression:
        inclusive-OR-expression
        logical-AND-expression "&&" inclusive-OR-expression
inclusive-OR-expression:
        exclusive-OR-expression
        inclusive-OR-expression "|" exclusive-OR-expression
exclusive-OR-expression:
        AND-expression
        exclusive-OR-expression "^" AND-expression
AND-expression:
        equality-expression
        AND-expression "&" equality-expression
equality-expression:
        relational-expression
        equality-expression "==" relational-expression
        equality-expression "!=" relational-expression
relational-expression:
        shift-expression
        relational-expression "<" shift-expression
        relational-expression ">" shift-expression
        relational-expression "<=" shift-expression
        relational-expression ">=" shift-expression
shift-expression:
        additive-expression
        shift-expression "<<" additive-expression
        shift-expression ">>" additive-expression
additive-expression:
        multiplicative-expression
        additive-expression "+" multiplicative-expression
        additive-expression "-" multiplicative-expression
multiplicative-expression:
        cast-expression
        multiplicative-expression "*" cast-expression
        multiplicative-expression "/" cast-expression
        multiplicative-expression "%" cast-expression
cast-expression:
        unary-expression
        "(" type-name ")" cast-expression
unary-expression:
        postfix-expression
        "++" unary-expression
        "--" unary-expression
        unary-operator cast-expression
        "sizeof" unary-expression
        "sizeof" "(" type-name ")"
postfix-expression:
        primary-expression
        postfix-expression "[" expression "]"
        postfix-expression "(" argument-expression-list? ")"
        postfix-expression "." identifier
        postfix-expression "->" identifier
        postfix-expression "++"
        postfix-expression "--"
        "(" type-name ")" "{" initializer-list "}"
        "(" type-name ")" "{" initializer-list "," "}"
primary-expression:
        identifier
        constant
        string-literal
        "(" expression ")"
expression:
        assignment-expression
        expression "," assignment-expression
argument-expression-list:
        assignment-expression
        argument-expression-list "," assignment-expression
type-name:
        specifier-qualifier-list abstract-declarator?
abstract-declarator:
        pointer
        pointer? direct-abstract-declarator
direct-abstract-declarator:
        "(" abstract-declarator ")"
        direct-abstract-declarator? "[" type-qualifier-list? assignment-expression? "]"
        direct-abstract-declarator? "[" "static" type-qualifier-list? assignment-expression "]"
        direct-abstract-declarator? "[" type-qualifier-list "static" assignment-expression "]"
        direct-abstract-declarator? "[" "*" "]"
        direct-abstract-declarator? "(" parameter-type-list? ")"
parameter-type-list:
        parameter-list
        parameter-list "," "..."
parameter-list:
        parameter-declaration
        parameter-list "," parameter-declaration
parameter-declaration:
        declaration-specifiers declarator
        declaration-specifiers abstract-declarator?
initializer-list:
        designation? initializer
        initializer-list "," designation? initializer
designation:
        designator-list "="
designator-list:
        designator
        designator-list designator
designator:
        "[" constant-expression "]"
        "." identifier
constant-expression:
        conditional-expression
initializer:
        assignment-expression
        "{" initializer-list "}"
        "{" initializer-list "," "}"
unary-operator:
        "&"
        "*"
        "+"
        "-"
        "~"
        "!"
assignment-operator:
        "="
        "*="
        "/="
        "%="
        "+="
        "-="
        "<<="
        ">>="
        "&="
        "^="
        "|="
identifier-list:
        identifier
        identifier-list "," identifier
enum-specifier:
        "enum" identifier? "{" enumerator-list "}"
        "enum" identifier? "{" enumerator-list "," "}"
        "enum" identifier
enumerator-list:
        enumerator
        enumerator-list "," enumerator
enumerator:
        enumeration-constant
        enumeration-constant "=" constant-expression
typedef-name:
        identifier
function-specifier:
        "inline"
declaration-list:
        declaration
        declaration-list declaration
declaration:
        declaration-specifiers init-declarator-list? ";"
init-declarator-list:
        init-declarator
        init-declarator-list "," init-declarator
init-declarator:
        declarator
        declarator "=" initializer
compound-statement:
        "{" block-item-list? "}"
block-item-list:
        block-item
        block-item-list block-item
block-item:
        declaration
        statement
statement:
        labeled-statement
        compound-statement
        expression-statement
        selection-statement
        iteration-statement
        jump-statement
labeled-statement:
        identifier ":" statement
        "case" constant-expression ":" statement
        "default" ":" statement
expression-statement:
        expression? ";"
selection-statement:
        "if" "(" expression ")" statement
        "if" "(" expression ")" statement "else" statement
        "switch" "(" expression ")" statement
iteration-statement:
        "while" "(" expression ")" statement
        "do" statement "while" "(" expression ")" ";"
        "for" "(" expression? ";" expression? ";" expression? ")" statement
        "for" "(" declaration expression? ";" expression? ")" statement
jump-statement:
        "goto" identifier ";"
        "continue" ";"
        "break" ";"
        "return" expression? ";"
		*/
typedef enum TYPEENUM {NOCHANGE=0,VOID	,POINTER,		INT		,FLOAT		,DOUBLE			,CHAR	} TYPEENUM;
int SIZEOF[]=     {0         ,0		,SIZEOFPTR	,	SIZEOFINT	,SIZEOFFLOAT,SIZEOFDOUBLE	,SIZEOFCHAR};
typedef struct TYPE{
		TYPEENUM t;
		int ptrcnt;//counts how many int ***a; stars we use for pointers
}TYPE;
#define strmax 1000 //amount of different identifiers
#define hashsize 4096 //hashmap size
typedef enum Ident {fn,varglob,varloc,ilbp} Ident; //the type of identifier: function, global variable, localvariable,  identinfo local base pointer
struct Identinfo;
typedef struct Identinfo{//datastructure for hashmap
	char *identstr;//the name of identifier
	int len;
	enum Ident identtype;//type of identifier
	u identptr;
	struct Identinfo *next;//list of identifier with same hash
	TYPE type;// DOUBLE, FLOAT ,INT,VOID also returntype
} Identinfo;
typedef struct CompileTypeStack{//type used for accessing last push such that typecast can be put before
	memptr typecastPC;
	TYPE type;
} CompileTypeStack;
typedef enum parsetype {unknown,vardef,varset,varget,adrget,functionname,parameter,typedefinition,enumdef,structdef,uniondef} parsetype;//the type of the currently parsed identifier:variable definition, assignement of a value to variable, evaluation of variable, function, parameter
struct info;
struct pos;
typedef struct pos{
	int getptremited;
	int allowingdollar;
	struct pos *parent;
	int initialized;
	char *c;
	struct info *i;
	int neednewlookup;
	memptr SP;
	memptr BP;
	Identinfo *ISP;//identifierStackPointer
	Identinfo *IBP;//identifierBasePointer
	Identinfo *ILBP;//local Basepointer of Interpreter
	Identinfo *functionIdentinfo;
	memptr PC;
	memptr constintpatchpos;
	char *cnext;
	const char *token;
}pos;
typedef struct info{
	Mode mode;//i386 print kvm
	char *err;
	int errprio;
	char *errpos;
	const char *errtoken;
	int in_function_definition;
//declaration
	TYPE type;
	int paramcnt;
	TYPE fnrettype;//used to get rettype during function definition
	const char *identifier;
	const char *identifierend;
	int global;
	char *str[strmax];
	int strcnt;
	int firstCBraOpenInFn;
	Identinfo *hashmap[hashsize];//new elements are inserted at beginning in list, bra and ket of while,... are not inserted in hashmap but only on ISP
	u* currentcall;
	u* currentvar;//currentvariable where emit(p,GETX) is performed where X is either L or G
	TYPE currenttype;//currenttype of primary expression
	int currentvarglobal;//1 if currentvariable where emit(p,GETG) is performed 
	ptrdiff offsetforlocals;//offset for local variables used if 
} info;
typedef struct iddata{
	char *str;
	int len;
	Identinfo* idinfo;
	enum parsetype parsing;
}iddata;
void inittables(info *i,char *s,mem *stack,pos *p){
	p->getptremited=0;
	p->allowingdollar=0;
	p->i=i;
	p->neednewlookup=1;
	p->c=s;
	i->err=0;
	i->errpos=0;
	i->errprio=0;
	p->PC.ptr=stack;
	i->strcnt=0;
	p->ISP=(Identinfo*)stackend.ptr;//i->identinfovarend;//Stack for Identinfo for variables
	p->SP.ptr=stackend.ptr;
	p->BP.ptr=stackend.ptr;
	memset(i->str,0,strmax*sizeof(char*));
	memset(i->hashmap,0,hashsize*sizeof(Identinfo *));
}
int hash(char *s,int len){//here we store all found identifier strings
	int n;
	int hash=0;
	if(len==0) return 0;
	for(n=0;n<len;n++){
		if(n&1) hash^=(s[n]&63)<<6;
		else hash^=s[n]&63;
	}
	return hash;
}
int strcmpid(iddata *id,char *s){
	int n;
	for(n=0;n<id->len;n++){
		if(id->str[n]!=s[n]) return 1;
	}
	return 0;
}


Identinfo *searchhash(info *i,iddata *id){//returns the first found entry or null if not found
	int h;
	Identinfo *idinfo;
	if(id->idinfo) return id->idinfo;
	if(id->str==0) {
		id->idinfo=0;
		return 0;
	}
	h=hash(id->str,id->len);
	idinfo=i->hashmap[h];
	while(idinfo){
		if(strcmpid(id,idinfo->identstr)==0) {
			id->idinfo=idinfo;
			return idinfo;
		}
		idinfo=idinfo->next;
	}
	id->idinfo=0;
	return 0;//not existing
}
void run(info *i){
	initinterpreter();
	BP.ptr=stackend.ptr;
	SP.ptr=stackend.ptr;
	PC.ptr=stack;
	SPGLOB=SP;
	execute();//execute global initializers
	SPGLOB=SP;
	BP=SP;
	execute();
}
void inserthash(info *i,Identinfo *id){
	int h=hash(id->identstr,id->len);
	id->next=i->hashmap[h];
	i->hashmap[h]=id;
}
int removehash(info *i,Identinfo *j){
	int h=hash(j->identstr,j->len);
	Identinfo *id=i->hashmap[h];
	Identinfo *prev=0;
	while(id){
		if(id==j){
			id->type.ptrcnt=0;
			if(!prev) i->hashmap[h]=id->next;
			else prev->next=id->next;
			return 1;
		}
		prev=id;
		id=id->next;
	}
	return 0;//not existing
}
//We need begin and end if the rule has several steps such as: "while" "(" expression ")" statement
//We need if(...){Begin... End} if we have many choices such as:
//        "do" statement "while" "(" expression ")" ";"
//        "for" "(" expression? ";" expression? ";" expression? ")" statement
#define Beginfn {pos p0=*p;{
#define Endfn *p=p0;}}
#define Begin {pos p0=*p;{
#define End }reject(&p0,p);}
void resetpos(pos *p0,pos *p){
	while(p->ISP<p0->ISP) {
		if(p->ISP->identstr!=0){
			if(p->ISP->identtype==fn) removehash(p->i,p->ISP);
			else if(p->ISP->identtype==varglob)removehash(p->i,p->ISP);
			else  if(p->ISP->identtype==varloc) removehash(p->i,p->ISP);
		}
		++p->ISP;
	}
	*p=*p0;
}
int reject(pos *p0,pos *p){
	while(p->ISP<p0->ISP) {
		if(p->ISP->identstr!=0){
			if(p->ISP->identtype==fn) removehash(p->i,p->ISP);
			else if(p->ISP->identtype==varglob)removehash(p->i,p->ISP); 
			else  if(p->ISP->identtype==varloc) removehash(p->i,p->ISP);
		}
		++p->ISP;
	}
	*p=*p0;
	return 0;
}
void advance(pos *p0,pos *p){
	*p0=*p;
}
void patch(voidfn p,void* PC){
	*((voidfn*)PC)=p;
}
void emit(pos *p,voidfn ptr){
	patch(ptr,p->PC.ptr);(p->PC.ptr)+=SIZEOFOP;
}
int emitexpression(pos *p,int (*fn)(pos*,iddata*),char *str,iddata *id){//emitexpression(p,declaration,"int SPARRAY$=99;");
	pos temppos;
	int ret;
	int neednewlookup=p->neednewlookup;
	p->neednewlookup=1;
	temppos=*p;
	temppos.c=str;
	temppos.allowingdollar=1;//now we can use the dollar sign for identifiers, this is for internal compiler usage such that no interference with user can occur
	ret=fn(&temppos,id);
	temppos.c=p->c;
	*p=temppos;
	p->allowingdollar=0;
	p->neednewlookup=neednewlookup;
	return ret;
}
void emitptr(pos *p,u *ptr){
	p->PC.Pu->Pu=ptr;(p->PC.ptr)+=SIZEOFPTR;
}
void emitptrd(pos *p,ptrdiff ptr){
	p->PC.Pu->ptrd=ptr;(p->PC.ptr)+=sizeof(ptrdiff);
}
void emitchar(pos *p,char c){
	p->PC.Pu->Char=c;(p->PC.ptr)+=SIZEOFCHAR;
}
void emitint(pos *p,int ptr){
	p->constintpatchpos=p->PC;
	p->PC.Pu->Int=ptr;(p->PC.ptr)+=SIZEOFINT;
}
void emitdouble(pos *p,double d){
	p->PC.Pu->Double=d;(p->PC.ptr)+=SIZEOFDOUBLE;
}
void emitTyped(pos *p,voidfn charop,voidfn intop,voidfn floatop,voidfn doubleop,voidfn ptrop){
	if(p->i->type.ptrcnt) {
		if(ptrop==DECPTR){
			emit(p,PUSHPTR);
			emit(p,CONST_INT);
			if(p->i->type.ptrcnt==1) emitint(p,SIZEOF[p->i->type.t]);//!!!!!!here we need instead of currenttype the type of first operant of pointerarithmetic
			else emitint(p,SIZEOF[POINTER]);
			emit(p,INT2PTR);
			emit(p,SUBPTR);
		}
		else if(ptrop==INCPTR){
			emit(p,PUSHPTR);
			emit(p,CONST_INT);
			if(p->i->type.ptrcnt==1) emitint(p,SIZEOF[p->i->type.t]);//!!!!!!here we need instead of currenttype the type of first operant of pointerarithmetic
			else emitint(p,SIZEOF[POINTER]);
			emit(p,INT2PTR);
			emit(p,ADDPTR);
		}
		else {
			if(ptrop==GETLPTR) p->getptremited=1;
			if(ptrop==GETGPTR) p->getptremited=1;
			emit(p,ptrop);
		}
		return;
	}
	switch(p->i->type.t){
	case CHAR:
			emit(p,charop);
			break;
		case  INT:		
			emit(p,intop);
			break;
		case  FLOAT:
			emit(p,floatop);
			break;
		case  DOUBLE:
			emit(p,doubleop);
			break;
		case POINTER:
			emit(p,ptrop);
			if(ptrop==GETLPTR) p->getptremited=1;
			if(ptrop==GETGPTR) p->getptremited=1;
			break;
		default:
			break;
	}
}
void emitTypeCast(pos *p,TYPE from,TYPE to){
	switch(from.t){
	case CHAR:
		switch(to.t){
		case CHAR:
			break;
		case INT:
			emit(p,CHAR2INT);p->i->type.t=INT;p->i->type.ptrcnt=0;
			break;
		case FLOAT:
			emit(p,CHAR2FLOAT);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;
			break;
		case DOUBLE:
			emit(p,CHAR2DOUBLE);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;
			break;
		default:
			break;
		}
		break;
	case INT:
		switch(to.t){
		case CHAR:
			emit(p,INT2CHAR);p->i->type.t=CHAR;p->i->type.ptrcnt=0;
			break;
		case INT:
			break;
		case FLOAT:
			emit(p,INT2FLOAT);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;
			break;
		case DOUBLE:
			emit(p,INT2DOUBLE);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;
			break;
		default:
			break;
		}
		break;
	case FLOAT:
		switch(to.t){
		case CHAR:
			emit(p,FLOAT2CHAR);p->i->type.t=CHAR;p->i->type.ptrcnt=0;
			break;
		case INT:
			emit(p,FLOAT2INT);p->i->type.t=INT;p->i->type.ptrcnt=0;
			break;
		case FLOAT:
			break;
		case DOUBLE:
			emit(p,FLOAT2DOUBLE);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;
			break;
		default:
			break;
		}
		break;
	case DOUBLE:
		switch(to.t){
		case CHAR:
			emit(p,DOUBLE2CHAR);p->i->type.t=CHAR;p->i->type.ptrcnt=0;
			break;
		case INT:
			emit(p,DOUBLE2INT);p->i->type.t=INT;p->i->type.ptrcnt=0;
			break;
		case FLOAT:
			emit(p,DOUBLE2FLOAT);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;
			break;
		case DOUBLE:
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
}
void emitPUSH(pos *p){
	p->ISP=(Identinfo*)((char*)p->ISP-sizeof(CompileTypeStack));
	if((char*)p->ISP<p->PC.ptr){
		printf( "Stackoverflow in compile time type calculation.\n");
		return;
	}
	((CompileTypeStack*)(p->ISP))->type=p->i->type;
	((CompileTypeStack*)(p->ISP))->typecastPC=p->PC;
	emitTyped(p,PUSHCHAR,PUSHINT,PUSHFLOAT,PUSHDOUBLE,PUSHPTR);
	emit(p,NOP);//to be replaced by typechanges or pushint
	emit(p,NOP);//const int
	emit(p,NOP);//num
	emit(p,NOP);//MULINT
	emit(p,NOP);//INT2PTR

}
void emitPOP(pos *p,TYPE cast){
	TYPE type=((CompileTypeStack*)(p->ISP))->type;
	p->ISP=(Identinfo*)((char*)p->ISP+sizeof(CompileTypeStack));
	if(cast.t==NOCHANGE) {
		if(type.ptrcnt>0){
			emit(p,POPPTR);
		}
		else switch(type.t){
		case CHAR:
			emit(p,POPCHAR);
			break;
		case  INT:
			emit(p,POPINT);
			break;
		case  FLOAT:
			emit(p,POPFLOAT);
			break;
		case  DOUBLE:
			emit(p,POPDOUBLE);
			break;
		default:
			break;
		}
	}
	else{//do typecasts
		if(cast.ptrcnt>0)  emit(p,POPPTR);
		else switch(cast.t){
		case  CHAR:
			emit(p,POPCHAR);
			break;
		case  INT:
			emit(p,POPINT);
			break;
		case  FLOAT:
			emit(p,POPFLOAT);
			break;
		case  DOUBLE:
			emit(p,POPDOUBLE);
			break;
		case POINTER:
			emit(p,POPPTR);
			break;
		default:
			break;
		}
	}
}
void killnop(pos* p,void *patchpos){//todo change killnop to do it without searching because we lknow how many nops we pushed

	memptr currentpc=p->PC;
	memptr pos;
	char *c;
	int cnt=0;
	for(pos.ptr=(char*)patchpos;pos.ptr<=currentpc.ptr;pos.ptr+=SIZEOFOP){
		if(pos.Pu->Voidfn!=NOP) break;	
		else ++cnt;
	}
	if(cnt){
		for(c=pos.ptr;c<=currentpc.ptr;++c) c[-cnt*SIZEOFOP]=*c;
		p->PC.ptr-=cnt*SIZEOFOP;
	}
}

void copyops(pos *p,memptr from,memptr to){
	ptrdiff d=p->PC.ptr-from.ptr;
	ptrdiff d2=from.ptr-to.ptr;
	memcpy(p->PC.ptr,from.ptr,d);
	memmove(to.ptr+d,to.ptr,d2);
	memcpy(to.ptr,p->PC.ptr,d);
}
void emitTypeCastedOp(pos *p,voidfn charop,voidfn intop,voidfn floatop,voidfn doubleop,voidfn ptrop){	
	TYPE poptype=((CompileTypeStack*)(p->ISP))->type;
	memptr patchpos=((CompileTypeStack*)(p->ISP))->typecastPC;
	memptr from;
	p->ISP=(Identinfo*)((char*)p->ISP+sizeof(CompileTypeStack));
	
	if(p->i->type.ptrcnt>0){
		if(poptype.ptrcnt>0) emit(p,ptrop);
		else if (poptype.t==INT){
/*
			from=p->PC;
			emit(p,PUSHINT);
			emit(p,CONST_INT);
			if(poptype.ptrcnt==1) emitint(p,SIZEOF[poptype.t]);//!!!!!!here we need instead of currenttype the type of first operant of pointerarithmetic
			else emitint(p,SIZEOF[POINTER]);
			emit(p,MULINT);
			emit(p,INT2PTR);
			emit(p,PUSHPTR);
			copyops(p,from,patchpos);
*/
			patch(PUSHINT,&(patchpos.Pu->VoidfnArr[0]));	
			patch(CONST_INT,&(patchpos.Pu->VoidfnArr[1]));	
			if(poptype.ptrcnt==1) patch((voidfn)SIZEOF[poptype.t],&(patchpos.Pu->VoidfnArr[2]));//!!!!!!here we need instead of currenttype the type of first operant of pointerarithmetic
			else patch((voidfn)SIZEOF[POINTER],&(patchpos.Pu->VoidfnArr[2]));
			patch(MULINT,&(patchpos.Pu->VoidfnArr[3]));
			patch(INT2PTR,&(patchpos.Pu->VoidfnArr[4]));
			patch(PUSHPTR,&(patchpos.Pu->VoidfnArr[5]));
			killnop(p,&(patchpos.Pu->VoidfnArr[6]));
			emit(p,ptrop);
		}
		else printf("uncompatible type pop\n");
	}
	else switch(p->i->type.t){
		case CHAR:{
			switch(poptype.t){
/*
			case CHAR:	emit(p,charop);break;
			case INT:	emit(p,CHAR2INT);emit(p,intop);p->i->type.t=INT;p->i->type.ptrcnt=0;	break;
			case FLOAT:	emit(p,INT2FLOAT);emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;		break;
			case DOUBLE:	emit(p,INT2DOUBLE);emit(p,doubleop);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;		break
*/
			case CHAR:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,charop);break;
			case INT:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,CHAR2INT);emit(p,intop);p->i->type.t=INT;p->i->type.ptrcnt=0;	break;
			case FLOAT:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,INT2FLOAT);emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;		break;
			case DOUBLE:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,INT2DOUBLE);emit(p,doubleop);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;		break;
			default:			printf("unknown type POP\n");
			}
			break;
		}
		case INT:{
			if(poptype.ptrcnt==0){
				switch(poptype.t){
/*
				case CHAR:	from=p->PC;emit(p,CHAR2INT);emit(p,PUSHINT);copyops(p,from,patchpos);emit(p,intop);p->i->type.t=INT;p->i->type.ptrcnt=0;	break;
				case INT:	emit(p,intop);	break;
				case FLOAT:	emit(p,INT2FLOAT);emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;		break;
				case DOUBLE:	emit(p,INT2DOUBLE);emit(p,doubleop);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;		break;
*/
				case CHAR:	patch(CHAR2INT,&(patchpos.Pu->VoidfnArr[0]));	patch(PUSHINT,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));emit(p,intop);p->i->type.t=INT;p->i->type.ptrcnt=0;	break;
				case INT:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,intop);	break;
				case FLOAT:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,INT2FLOAT);emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;		break;
				case DOUBLE:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,INT2DOUBLE);emit(p,doubleop);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;		break;

				default:			printf("unknown type POP\n");
				}
			}
			else{
				killnop(p,&(patchpos.Pu->VoidfnArr[1]));
				emit(p,PUSHINT);
				emit(p,CONST_INT);
				if(poptype.ptrcnt==1) emitint(p,SIZEOF[poptype.t]);//!!!!!!here we need instead of currenttype the type of first operant of pointerarithmetic
				else emitint(p,SIZEOF[POINTER]);
				emit(p,MULINT);
				emit(p,INT2PTR);
				emit(p,ptrop);p->i->type.t=poptype.t;p->i->type.ptrcnt=poptype.ptrcnt;		break;
			}
			break;
		}
		case FLOAT:{
			switch(poptype.t){
/*			case CHAR:	from=p->PC;emit(p,CHAR2FLOAT);emit(p,PUSHFLOAT);copyops(p,from,patchpos);emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;	break;
			case INT:	from=p->PC;emit(p,INT2FLOAT);emit(p,PUSHFLOAT);copyops(p,from,patchpos);emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;	break;
			case FLOAT:	emit(p,floatop);break;
			case DOUBLE:emit(p,FLOAT2DOUBLE);emit(p,doubleop);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;	break;
*/
			case CHAR:	patch(CHAR2FLOAT,&(patchpos.Pu->VoidfnArr[0]));	patch(PUSHFLOAT,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;	break;
			case INT:		patch(INT2FLOAT,&(patchpos.Pu->VoidfnArr[0]));	patch(PUSHFLOAT,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));emit(p,floatop);p->i->type.t=FLOAT;p->i->type.ptrcnt=0;	break;
			case FLOAT:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,floatop);break;
			case DOUBLE:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));emit(p,FLOAT2DOUBLE);emit(p,doubleop);p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;	break;

			default:			printf("unknown type POP\n");
			}	
			break;
		}
		case DOUBLE:{
			switch(poptype.t){
/*			case CHAR:	from=p->PC;emit(p,CHAR2DOUBLE);emit(p,PUSHDOUBLE);copyops(p,from,patchpos);break;
			case INT:	from=p->PC;emit(p,INT2DOUBLE);emit(p,PUSHDOUBLE);copyops(p,from,patchpos);break;
			case FLOAT:	from=p->PC;emit(p,FLOAT2DOUBLE);emit(p,PUSHDOUBLE);copyops(p,from,patchpos);break;
			case DOUBLE:break;
*/
			case CHAR:	patch(CHAR2DOUBLE,&(patchpos.Pu->VoidfnArr[0]));	patch(PUSHDOUBLE,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));break;
			case INT:	patch(INT2DOUBLE,&(patchpos.Pu->VoidfnArr[0]));patch(PUSHDOUBLE,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));break;
			case FLOAT:	patch(FLOAT2DOUBLE,&(patchpos.Pu->VoidfnArr[0]));patch(PUSHDOUBLE,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));break;
			case DOUBLE:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));break;

			default:			printf("unknown type POP\n");
			}
			emit(p,doubleop);
			p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;
			break;
		}
		default:	printf("unknown type\n");
	}
	
}
void emitSET(pos *p,TYPE ptrtype,u *setptr,char *idstr,int len,voidfn charop,voidfn intop,voidfn floatop,voidfn doubleop,voidfn ptrop,voidfn getptr){//TODO do integer to ptr typecast@@@@@@@@@@@@@
	int emitsetptr=1;
	int cnt;
	if(ptrtype.ptrcnt!=0){	//TODO proper error checking
		if(p->i->type.ptrcnt==0){//we have a dereved lhs ptr
			emitsetptr=0;
			switch(ptrtype.t){//TODO we need to make multiples dereff when **pp=...
			case CHAR:
				switch(p->i->type.t){
				case CHAR:
					break;
				case INT:
					emit(p,INT2CHAR);
					break;
				case FLOAT:
					emit(p,FLOAT2CHAR);
					break;
				case DOUBLE:
					emit(p,DOUBLE2CHAR);
					break;
				default:
					break;
				}
				emit(p,POPPTRPUSHCHAR);
				for(cnt=1;cnt<ptrtype.ptrcnt;cnt++) emit(p,DEREFPTR);
				emit(p,SETPTRCHAR);
				break;
			case INT:
				switch(p->i->type.t){
				case CHAR:
					emit(p,CHAR2INT);
					break;
				case INT:
					break;
				case FLOAT:
					emit(p,FLOAT2INT);
					break;
				case DOUBLE:
					emit(p,DOUBLE2INT);
					break;
				default:
					break;
				}
				emit(p,POPPTRPUSHINT);
			
				for(cnt=1;cnt<ptrtype.ptrcnt;cnt++) emit(p,DEREFPTR);
				emit(p,SETPTRINT);
				break;
			case FLOAT:
				switch(p->i->type.t){
				case CHAR:
					emit(p,CHAR2FLOAT);
					break;
				case INT:
					emit(p,INT2FLOAT);
					break;
				case FLOAT:
					break;
				case DOUBLE:
					emit(p,DOUBLE2FLOAT);
					break;
				default:
					break;
				}
				emit(p,POPPTRPUSHFLOAT);

				for(cnt=1;cnt<ptrtype.ptrcnt;cnt++) emit(p,DEREFPTR);
				emit(p,SETPTRFLOAT);
				break;
			case DOUBLE:
				switch(p->i->type.t){
				case CHAR:
					emit(p,CHAR2DOUBLE);
					break;
				case INT:
					emit(p,INT2DOUBLE);
					break;
				case FLOAT:
					emit(p,FLOAT2DOUBLE);
					break;
				case DOUBLE:
					break;
				default:
					break;
				}
				emit(p,POPPTRPUSHDOUBLE);

				for(cnt=1;cnt<ptrtype.ptrcnt;cnt++) emit(p,DEREFPTR);
				emit(p,SETPTRDOUBLE);
				break;
			default:
				break;
		}
		}
		else if(ptrtype.t==p->i->type.t)
			if(ptrtype.ptrcnt+1==p->i->type.ptrcnt) {
				emit(p,POPPTRPUSHPTR);
				for(cnt=1;cnt<ptrtype.ptrcnt;cnt++) emit(p,DEREFPTR);
				emit(p,SETPTRPTR);
			}
			else if(ptrtype.ptrcnt==p->i->type.ptrcnt)  emit(p,ptrop);
		else printf("ERROR emitSET Pointer wrong type!");
	}
	else switch(ptrtype.t){
		case CHAR:
			switch(p->i->type.t){
			case CHAR:
				break;
			case INT:
				emit(p,INT2CHAR);
				break;
			case FLOAT:
				emit(p,FLOAT2CHAR);
				break;
			case DOUBLE:
				emit(p,DOUBLE2CHAR);
				break;
			default:
				break;
			}
			emit(p,charop);
			break;
		case INT:
			switch(p->i->type.t){
			case CHAR:
				emit(p,CHAR2INT);
				break;
			case INT:
				break;
			case FLOAT:
				emit(p,FLOAT2INT);
				break;
			case DOUBLE:
				emit(p,DOUBLE2INT);
				break;
			default:
				break;
			}
			emit(p,intop);
			break;
		case FLOAT:
			switch(p->i->type.t){
			case CHAR:
				emit(p,CHAR2FLOAT);
				break;
			case INT:
				emit(p,INT2FLOAT);
				break;
			case FLOAT:
				break;
			case DOUBLE:
				emit(p,DOUBLE2FLOAT);
				break;
			default:
				break;
			}
			emit(p,floatop);
			break;
		case DOUBLE:
			switch(p->i->type.t){
			case CHAR:
				emit(p,CHAR2DOUBLE);
				break;
			case INT:
				emit(p,INT2DOUBLE);
				break;
			case FLOAT:
				emit(p,FLOAT2DOUBLE);
				break;
			case DOUBLE:
				break;
			default:
				break;
			}
			emit(p,doubleop);
			break;
		default:
			break;
	}
#ifdef DODEBUG
	if(emitsetptr) {
		emitptr(p,(u*)idstr);
		emitint(p,len);
	}
	printf("emitSET ");
	printfid(idstr,len);
	printf("\n");
#endif
	if(emitsetptr) emitptr(p,setptr);
}
void emitGETL(pos *p,iddata *id){
	emitTyped(p,GETLCHAR,GETLINT,GETLFLOAT,GETLDOUBLE,GETLPTR);
#ifdef DODEBUG
	emitptr(p,(u*)id->str);
	emitint(p,id->len);
	printf("emitGETL ",id->len);
	printfid(id->str,id->len);
	printf("\n");
#endif
}
void emitGETG(pos *p,iddata *id){
	emitTyped(p,GETGCHAR,GETGINT,GETGFLOAT,GETGDOUBLE,GETGPTR);
#ifdef DODEBUG
	emitptr(p,(u*)id->str);
	emitint(p,id->len);
	printf("emitGETG ");
	printfid(id->str,id->len);
	printf("\n");
#endif
}
int D(pos *p,int *digit){//[0-9]
	char **c=&(p->c);
	if ((**c>='0') && (**c<='9')){*digit=**c-'0';++*c;return 1;}
	else return 0;
}
int L(pos *p){//[a-zA-Z_] if allowingdollar==1 [a-zA-Z_$]
	char **c=&(p->c);
	if((**c>='a') && (**c<='z')){++(*c);return 1;}
	else if((**c>='A') && (**c<='Z')){++*c;return 1;}
	else if(**c=='_') {++*c;return 1;}
	else {
		if(p->allowingdollar) {if(**c=='$') {++*c;return 1;}}
	    return 0;
	}
}
int H(pos *p){//[a-fA-F0-9]
	char **c=&(p->c);
	int digit;
	if(D(p,&digit)) return 1;
	else if((**c>='a') && (**c<='f')) {++*c;return 1;}
	else if((**c>='A') && (**c<='F')) {++*c;return 1;}
	else return 0;
}
int E(pos *p,int *num){//[Ee][+-]?{D}+
	char **c=&(p->c);
	int sign=1,digit;
	char *d=*c;
	*num=0;
	if(**c=='e' || **c=='E'){
		++*c;
		if( (**c=='+') || **c=='-'){
			if(**c=='-') sign=-1;
			++*c;
		}
		if(D(p,&digit)) {
			*num=digit;
			while(D(p,&digit)){
				*num=*num*10+digit;
			}
			*num*=sign;
			return 1;
		}
		else {*c=d;return 0;}
	}
	else {*c=d;return 0;}
}
int FS(pos *p){//(f|F|l|L) //floating point suffix
	char **c=&(p->c);
	if(**c=='f') {++*c;return 1;}
	else if(**c=='F') {++*c;return 1;}
	else if(**c=='l') {++*c;return 1;}
	else if(**c=='L') {++*c;return 1;}
	else return 0;
}
int IS(pos *p){//(u|U|l|L)*
	char **c=&(p->c);
	if(**c=='u') {++*c;return 1;}
	else if(**c=='U') {++*c;return 1;}
	else if(**c=='l') {++*c;return 1;}
	else if(**c=='L') {++*c;return 1;}
	else return 0;

}
int space(pos *p){
	char **c=&(p->c);
	char *d=*c;
	while(1){
		if(**c==' ') ++*c;
		else if(**c=='\n') ++*c;
		else if(**c=='\r') ++*c;
		else if(**c=='\t') ++*c;
		else if(**c=='\v') ++*c;
		else if(**c=='\f') ++*c;
		else if(**c=='/'){
			++*c;
			if(**c=='/'){
				++*c;
				while(1){
					if(**c=='\n'){++*c; break;}
					if(**c=='\r'){++*c; break;}
					if(**c==0){ break;}
					else ++*c; 
				}
			}
			else if(**c=='*'){
				++*c;
				while(1){
					if(**c=='*'){
						++*c;
						if(**c=='/'){++*c;break;}
					}
					else ++*c;
				}
			}
			else{--*c;break;}
		}
		else break;
	}
	if(*c==d) return 0;
	else return 1;
}
int identifier(pos *p,iddata *id){//{L}({L}|{D})*
	info *i=p->i;
	char **c=&(p->c);
	char *idexp="ERROR Identifier expected";
	int errprio=2;
	int digit;
	char *d;
	space(p);
	d=*c;
	if(L(p)){
		while(L(p) || D(p,&digit) );
		i->identifier=d;
		i->identifierend=*c;
		id->str=d;
		id->len=*c-d;
		id->idinfo=0;
		p->neednewlookup=1;
		return 1;
	}
	else {
		if((*c>=i->errpos) && (errprio>=i->errprio)){
			i->errprio=errprio;
			i->err=idexp;
			i->errpos=*c;
			i->errtoken=0;
		}
		*c=d;
		return 0;
	}
}
int hexconstant(pos *p){//0[xX]{H}+{IS}?	
	info *i=p->i;
	char **c=&(p->c);
	char *hexformaterror="ERROR in hexadecimal format";
	char *d;
	space(p);
	d=*c;
	if(**c=='0'){
		++*c;
		if((**c=='x') || (**c=='X')) ++*c;
		else {*c=d;return 0;}
		if(H(p)){
			while(H(p));
			IS(p);
			p->neednewlookup=1;
			return 1;
		}
		else {
			if((*c>=i->errpos) && (0>=i->errprio)){
				i->err=hexformaterror;
				i->errprio=0;
				i->errpos=*c;	
				i->errtoken=0;		
			}
			*c=d;
			return 0;
		}
	}
	else {*c=d;return 0;}
}
int octconstant(pos *p){//0{D}+{IS}?
	char **c=&(p->c);
	int digit;
	char *d;
	space(p);
	d=*c;
	if(**c=='0'){
		++*c;
		if(D(p,&digit));
		else{*c=d;return 0;}
		while (D(p,&digit));
		IS(p);
		p->neednewlookup=1;
		return 1;
	}
	else {*c=d;return 0;}
}
int intconstant(pos *p){//{D}+{IS}?
	info *i=p->i;
	char *d;	
	int intconst,digit;
	space(p);
	d=p->c;
	if(D(p,&digit)){
		intconst=digit;
		while(D(p,&digit)) 
		intconst=intconst*10+digit;
		IS(p);
		i->type.t=INT;
		i->type.ptrcnt=0;
		emit(p,CONST_INT);//2
		emitint(p,intconst);//2
		p->neednewlookup=1;
		return 1;
	}
	else{p->c=d;return 0;}
}
int charconstant(pos *p){//L?'(\\.|[^\\'])+'
	char **c=&(p->c);
	char *d;
	char ch;
	space(p);
	d=*c;
	if(**c=='\''){
		++*c;
		if(**c!='\''){
			ch=**c;
			++*c;
			if(**c=='\'') {
				++*c;
				p->i->type.t=CHAR;
				p->i->type.ptrcnt=0;
				emit(p,CONST_CHAR);
				emitchar(p,ch);
				p->neednewlookup=1;
				return 1;
			}
			else {*c=d;return 0;}
		}
		else{*c=d; return 0;}
	}
	else{*c=d; return 0;}
}
int doubleconstant1(pos *p){//{D}+{E}{FS}?	
	info *i=p->i;
	char **c=&(p->c);
	char *d;
	int expo=0,digit;
	double dc=0.;
	space(p);
	d=*c;
	if(D(p,&digit)) {
		dc=digit;
		while(D(p,&digit)) dc=dc*10.+digit;
		if(E(p,&expo));
		else {*c=d;return 0;}
		FS(p);
		i->type.t=DOUBLE;
		i->type.ptrcnt=0;
		emit(p,CONST_DOUBLE);//2
		emitdouble(p,dc);//2
		p->neednewlookup=1;
		return 1;
	}
	else{*c=d; return 0;}
}
int doubleconstant2(pos *p){//{D}*"."{D}+({E})?{FS}?  //{D}+"."{D}*({E})?{FS}?
	info *i=p->i;
	char **c=&(p->c);
	int pre=0,post=0,expo=0,digit;
	double postnum=0.1;
	double dc=0;
	char *d;
	space(p);
	d=*c;
	if(D(p,&digit)){
		pre=1;
		dc=digit;
	}
	while(D(p,&digit)) dc=dc*10.+digit;
	if(**c=='.') ++*c;
	else{*c=d; return 0;}
	if(D(p,&digit)) {
		dc+=digit*postnum;
		postnum*=0.1;
		post=1;
	}
	while(D(p,&digit)) {
		dc+=postnum*digit;
		postnum*=0.1;
	}
	if(E(p,&expo)) dc*=pow(10.,expo);
	FS(p);
	if(pre || post){
		i->type.t=DOUBLE;
		i->type.ptrcnt=0;
		emit(p,CONST_DOUBLE);//2
		emitdouble(p,dc);//2
		p->neednewlookup=1;
		return 1;
	}
	else {*c=d;return 0;}
}
int stringliteral(pos *p){//L?\"(\\.|[^\\"])*\"
	char **c=&(p->c);
	char *d;
	space(p);
	d=*c;
	if(**c=='"') {
		++*c;
		while(1){
			if(! **c) {*c=d;return 0;}
			if(**c=='"')
				if(*(*c-1)!='\\') {
					++*c;
					p->neednewlookup=1;
					return 1;
				}
			++*c;
		}
	}
	else {*c=d;return 0;}
}
int match(const char *token, pos *p){//token must be a string constant! 
	static char *err="ERROR: Expecting :";
	info *i=p->i;
	char **c=&(p->c);
	const char *tokenlistiter;
	int k;
	if(!**c) return 0;
	if(p->neednewlookup){//we need new lookup or comparison
		space(p);
		p->cnext=*c;
		p->token=0;
		k=tokenlookup[(**c-32)&127];
		p->neednewlookup=0;
		if(k){//first letter match
			do{//try all tokens with same starting letter
				tokenlistiter=tokenlist[k];
				++(p->cnext);//advance cnext
				++tokenlistiter;
				while(*tokenlistiter){
					if(*(p->cnext)!=*tokenlistiter) break;
					++tokenlistiter;
					++(p->cnext);
				}
				if(!(*tokenlistiter)) {
					p->token=tokenlist[k];//found it//we need to try longest match
					break;
				}
				++k;//try next token from tokenlist
				(p->cnext)=*c;//restart
			}while((k<128-32)&&(tokenlist[k][0]==**c));//continue if we have still same startingletter
		}
	}
	if(p->token==token){
		*c=p->cnext;//advance
		p->neednewlookup=1;
		return 1;
	}
	else {
		if((p->cnext>=i->errpos) && (0>=i->errprio)){
			i->errtoken=token;
			i->err=err;
			i->errprio=0;
			i->errpos=p->cnext;
		}
		return 0;
	}
}
int matchstring(const char *token, pos *p){//token must be a string constant! 
	info *i=p->i;
	static char *err="ERROR: Expecting :";
	char **c=&(p->c);
	char *d;
	space(p);
	d=p->c;
	p->token=token;
	while(*token){
		if(**c!=*token) break;
		++token;
		++*c;
	}
	if(!(*token)) {
//		p->token=i->errtoken;
		p->neednewlookup=1;
		return 1;
	}
	else{
		if((*c>=i->errpos) && (0>=i->errprio)){
			i->errtoken=p->token;
			i->err=err;
			i->errprio=0;
			i->errpos=*c;
		}
		p->c=d;
		return 0;
	}
}
int expression(pos *p,iddata *id);
int statement(pos *p,iddata *id);
int constant_expression(pos *p,iddata *id);
//jump-statement:
//        "goto" identifier ";"
//        "continue" ";"
//        "break" ";"
//        "return" expression? ";"
int jump_statement(pos *p,iddata *id){
	Beginfn
		if(match(Goto,p)){
			if(identifier(p,id)){
				if(match(Semicolon,p)) return 1;
			}
			return reject(&p0,p);
		}
		if(match(Continue,p)){
			if(match(Semicolon,p)) return  1;
			return reject(&p0,p);
		}
		if(match(Break,p)){
			if(match(Semicolon,p)) return 1;
			return reject(&p0,p);
		}
		if(match(Return,p)){
			if(expression(p,id));
			if(match(Semicolon,p)) {
				emitTypeCast(p,p->i->type,p->i->fnrettype);		
				emit(p,RET);
				return 1;
			}
			return reject(&p0,p);
		}	
		return reject(&p0,p);
	Endfn
}
	//iteration-statement:
	//        "while" "(" expression ")" statement
	//        "do" statement "while" "(" expression ")" ";"
	//        "for" "(" expression? ";" expression? ";" expression? ")" statement
	//this line is wrong        "for" "(" declaration expression? ";" expression? ")" statement
int iteration_statement(pos *p,iddata *id){
	Beginfn
		memptr jmp2,jmppos1;
		if(match(While,p)){
			if(match(BraOpen,p)){
	jmp2=p->PC;
				if(expression(p,id)){
					if(match(BraClose,p)){
						emit(p,NOT);
						emit(p,IFJMP);
					jmppos1=p->PC;
						emitptrd(p,0);
						if(statement(p,id)) {
							emit(p,JMP);
							emitptrd(p,jmp2.ptr-p->PC.ptr);
							jmppos1.Pu->ptrd=p->PC.ptr-jmppos1.ptr;
							return 1;
						}
					}
				}
			}
			return reject(&p0,p);
		}
		if(match(Do,p)){
			memptr jmp1=p->PC;
			if(statement(p,id)){
				if(match(While,p)){
					if(match(BraOpen,p)){
						if(expression(p,id)){
							if(match(BraClose,p)){
								if(match(Semicolon,p)){
									emit(p,IFJMP);
									emitptrd(p,jmp1.ptr-p->PC.ptr);
									return 1;
								}
							}
						}
					}
				}
			}
			return reject(&p0,p);
		}
		if(match(For,p)){
				if(match(BraOpen,p)){
					if(expression(p,id));//init
					if(match(Semicolon,p)){
						memptr jmp1=p->PC;//a
						memptr jmppos2;
						memptr jmppos3;
						memptr jmp4;
						int havecondition=0;
						if(expression(p,id)){//condition
							emit(p,NOT);
							emit(p,IFJMP);
							jmppos2=p->PC;//to d
							emitptrd(p,0);
							emit(p,JMP);
							jmppos3=p->PC;//to b
							emitptrd(p,0);
							havecondition=1;
						}
						if(match(Semicolon,p)){
							jmp4=p->PC;//c
							if(expression(p,id));//inc
							emit(p,JMP);
							emitptrd(p,jmp1.ptr-p->PC.ptr);// to a
							if(havecondition) jmppos3.Pu->ptrd=p->PC.ptr-jmppos3.ptr;//b
							if(match(BraClose,p)){
								if(statement(p,id)){
									emit(p,JMP);
									emitptrd(p,jmp4.ptr-p->PC.ptr);// to c
									if(havecondition) jmppos2.Pu->ptrd=p->PC.ptr-jmppos2.ptr;//d
									return 1;
								}
							}
						}
					}
				}
			return reject(&p0,p);
		}
		return reject(&p0,p);
	Endfn
}
	//selection-statement:
	//        "if" "(" expression ")" statement
	//        "if" "(" expression ")" statement "else" statement
	//        "switch" "(" expression ")" statement
int selection_statement(pos *p,iddata *id){
	Beginfn
		info *i=p->i;
		memptr jmppos1,jmppos2;
		if(match(If,p)){
				if(match(BraOpen,p)){
					if(expression(p,id)){
						if(match(BraClose,p)){
							emit(p,NOT);
							emit(p,IFJMP);
					jmppos1=p->PC;//-> 1
							emitptrd(p,0);
							if(statement(p,id)){
								Begin//???????????????????????????????????????
									emit(p,JMP);
						jmppos2=p->PC;//->2
									emitptrd(p,0);
									jmppos1.Pu->ptrd=p->PC.ptr-jmppos1.ptr;//1			
									if(match(Else,p)){
										if(statement(p,id)) {
											jmppos2.Pu->ptrd=p->PC.ptr-jmppos2.ptr;//2
											return 1;
										}
									}
								End
								jmppos1.Pu->ptrd=p->PC.ptr-jmppos1.ptr;//1
								return 1;
							}
						}
					}
				}
			return reject(&p0,p);
		}
		if(match(Switch,p)){
			if(match(BraOpen,p)){
				if(expression(p,id)){
					if(match(BraClose,p)){
						if(statement(p,id)) return 1;
					}
				}
			}
		}
		return reject(&p0,p);
	Endfn
}
//expression-statement:
//        expression? ";"
int expression_statement(pos *p,iddata *id){
	Beginfn
		if(expression(p,id));
		if(match(Semicolon,p)) return 1;
		return reject(&p0,p);
	Endfn
}
//labeled-statement:
//        identifier ":" statement
//        "case" constant-expression ":" statement
//        "default" ":" statement
int labeled_statement(pos *p,iddata *id){
	Beginfn
		if(identifier(p,id)){
			if(match(Colon,p)){
				if(statement(p,id)) return 1;
			}
			resetpos(&p0,p);
		}
		if(match(Case,p)){
			if(constant_expression(p,id)){
				if(match(Colon,p)){
					if(statement(p,id)) return 1;
				}
			}
			return reject(&p0,p);
		}
		if(match(Default,p)){
			if(match(Colon,p)){
				if(statement(p,id)) return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
int compound_statement(pos *p,iddata *id);
int expression_statement(pos *p,iddata *id);
int user_defined_statement(pos *p,iddata *id){
	Beginfn
		if(matchstring("print",p)){
			if(match(BraOpen,p))
				if(expression(p,id))
					if(match(BraClose,p)){
						emitTyped(p,PRINTCHAR,PRINTINT,PRINTFLOAT,PRINTDOUBLE,PRINTPTR);
						return 1;
					}
			resetpos(&p0,p);
		}
		if(matchstring("input",p)){
			if(match(BraOpen,p))
				if(expression(p,id))
					if(match(BraClose,p)){
						emitTyped(p,INPUTCHAR,INPUTINT,INPUTFLOAT,INPUTDOUBLE,INPUTPTR);
						return 1;
					}
		}
		return reject(&p0,p);
	Endfn
}
//statement:
//        labeled-statement
//        compound-statement
//        expression-statement
//        selection-statement
//        iteration-statement
//        jump-statement
int statement(pos *p,iddata *id){
	if(labeled_statement(p,id)) return 1;
	else if(compound_statement(p,id)) return 1;
	else if(expression_statement(p,id)) return 1;
	else if(selection_statement(p,id)) return 1;
	else if(iteration_statement(p,id)) return 1;
    else if(jump_statement(p,id)) return 1;
	else if(user_defined_statement(p,id)) return 1;
	return 0;
}
int declaration(pos *p);
//block-item:
//        declaration
//        statement
int block_item(pos *p,iddata *id){
	if(declaration(p)) return 1;
	else if(statement(p,id)) return 1;
	return 0;
}
//block-item-list:
//        block-item
//        block-item-list block-item
int block_item_list(pos *p,iddata *id){
	if(block_item(p,id)){
		while(1){
			if(block_item(p,id)) continue;
			else return 1;
		}
	}
	return 0;
}
//compound-statement:
//        "{" block-item-list? "}"
int compound_statement(pos *p,iddata *id){
	Beginfn
		info *i=p->i;
		Identinfo *ILBPtemp;
	if(match(CBraOpen,p)){
			char *sparray;
			memptr patchpos;
			int firstCBraOpenInFn=i->firstCBraOpenInFn;//we avoid the local begin if we are in a function after the first CBraOpen
			//we have a local bracket
			i->firstCBraOpenInFn=0;
			if(!firstCBraOpenInFn){
				emit(p,BEGIN);
				//we need to change LBP
				//ksksks todo we do not detect fn(int a){int a;
				p->ISP--;
				p->SP.ptr-=SIZEOFPTR;
				//we should do this but it is not needed i->ISP->identptr.PVoid=i->SP.ptr;
				ILBPtemp=p->ISP;
				p->ISP->identstr=0;
				p->ISP->identtype=ilbp;
				p->ISP->identptr.PVoid=p->ILBP;//thus we abuse identptr to store the ILBP
				p->ILBP=ILBPtemp;
			}
			sparray=p->SP.ptr;
			emit(p,PUSHN);
			patchpos=p->PC;//to d
			emitint(p,0);
			if(block_item_list(p,id));
			patchpos.Pu->Int=sparray-p->SP.ptr;//correction factor for arrays on stack
			if (match(CBraClose,p)){
				if(!firstCBraOpenInFn){
					emit(p,END);
					while(p->ISP < p->ILBP) {
						int inc;
						if(p->ISP->type.ptrcnt==0) inc=SIZEOF[p->ISP->type.t];
						else inc=SIZEOF[POINTER];
						p->SP.ptr+=inc;
						removehash(i,p->ISP);
						++p->ISP;
					}
					p->ISP=p->ILBP;
					p->ILBP=(Identinfo *)p->ISP->identptr.PVoid;//abused identptr for storage of ilbp
					p->SP.ptr+=SIZEOFPTR;
					++p->ISP;
				}
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
int declarator(pos *p,iddata *id);
int initializer(pos *p,iddata *id);
int handledef(pos *p,int parameter,iddata *id){
	Beginfn
		info *i=p->i;
		Identinfo *ii;
		int errprio=4;
		if(!id->str) {
			printf("empty identifier name. can happen in forward decl.\n");
			return reject(&p0,p);
		}
		ii=searchhash(i,id);
		if(ii){
			if(ii->identtype==fn) {
				if((p->c>=i->errpos) && (errprio>=i->errprio) ){
					static char *err="variable declaration uses already defined function name\n";
					i->err=err;
					i->errprio=errprio;
					i->errpos=p->c;
					i->errtoken=id->str;
				}
				return reject(&p0,p);
			}
			if(i->global && ii->identtype==varglob) {
				if((p->c>=i->errpos)&& (errprio>=i->errprio)){
					static char *err="Already defined global variable\n";
					i->err=err;
					i->errprio=errprio;
					i->errpos=p->c;
					i->errtoken=id->str;
				}
				return reject(&p0,p);
			}
			if((!i->global) && (ii->identtype==varloc) && (ii<=p->ILBP)) {
				if((p->c>=i->errpos)&& (errprio>=i->errprio)){
					static char *err="Already defined local variable\n";
					i->err=err;
					i->errprio=errprio;
					i->errpos=p->c;
					i->errtoken=id->str;
				}
				return reject(&p0,p);
			}
		}
		p->ISP--;
		if((char*)p->ISP<p->PC.ptr){	
			static char *err="Identinfovar stack overflow\n";
			i->err=err;
			i->errpos=p->c;
			i->errprio=errprio;
			i->errtoken=0;
			return reject(&p0,p);
		}
		p->ISP->identstr=id->str;
		if(i->global) {
			int dec;
			p->ISP->identtype=varglob;
			p->ISP->type=i->type;
			if(i->type.ptrcnt==0) dec=SIZEOF[i->type.t];
			else dec=SIZEOF[POINTER];
			p->SP.ptr-=dec;
			p->ISP->identptr.PVoid=p->SP.ptr;
		}
		else{
			int dec;
			p->ISP->identtype=varloc;
			p->ISP->type=i->type;
			if(i->type.ptrcnt==0) dec=SIZEOF[i->type.t];
			else dec=SIZEOF[POINTER];
			p->SP.ptr-=dec;
			p->ISP->identptr.ptrd=(p->SP.ptr-p->BP.ptr-i->offsetforlocals);//!!
		}
		p->ISP->type=i->type;
		p->ISP->len=id->len;
		inserthash(i,p->ISP);
		return 1;
	Endfn
}
//init-declarator:
//        declarator
//        declarator "=" initializer
int init_declarator(pos *p,iddata *id){
	Beginfn
		int num;
		if(num=declarator(p,id)){
			if (!handledef(p,0,id)){
				return reject(&p0,p);
			}
			if(p->i->type.ptrcnt!=0){
				if(num==3){//we have array def
					emit(p,PUSHINT);
					emit(p,CONST_INT);
					if(p->i->type.ptrcnt==1) emitint(p,SIZEOF[p->i->type.t]);
					else emitint(p,SIZEOF[POINTER]);
					emit(p,MULINT);
					emit(p,DEFARR);
					emitint(p,p->ISP->identptr.Int);
					if(p->i->type.ptrcnt==1) emitint(p,SIZEOF[p->i->type.t]);
					else emitint(p,SIZEOF[POINTER]);
#ifdef DODEBUG
					emitptr(p,(u*)id->str);
					emitint(p,id->len);
					printf("emitDEFPTR ");
					printfid(id->str,id->len);
					printf("\n");
#endif		
				}
			}
			advance(&p0,p);
			if(match(Eq,p)){
				//now we can replace a set by set2local or set2global
				u* setptr=p->ISP->identptr.Pu;
				TYPE ptrtype=p->ISP->type;	
				int setglobal=p->i->global;
				if(initializer(p,id)){
					if(setglobal) emitSET(p,ptrtype,setptr,id->str,id->len,SETGCHAR,SETGINT,SETGFLOAT,SETGDOUBLE,SETGPTR,GETGPTR);//2
					else  emitSET(p,ptrtype,setptr,id->str,id->len,SETLCHAR,SETLINT,SETLFLOAT,SETLDOUBLE,SETLPTR,GETLPTR);//2
					return 1;
				}
			}
			resetpos(&p0,p);
			return 1;
		}
		return reject(&p0,p);
	Endfn
}
//init-declarator-list:
//        init-declarator
//        init-declarator-list "," init-declarator
int init_declarator_list(pos *p,iddata *id){
	Beginfn
		if(init_declarator(p,id)){
			while(1){
				advance(&p0,p);//advance does not work
				if(match(Comma,p)){
					if(init_declarator(p,id)) continue;
				}
				else 1;
				resetpos(&p0,p);
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
int declaration_specifiers(pos *p);
//declaration:
//        declaration-specifiers init-declarator-list? ";"
int declaration(pos *p){
	Beginfn
		iddata vardefid;
		vardefid.parsing=vardef;
		vardefid.str=0;
		if(declaration_specifiers(p)){
			if(init_declarator_list(p,&vardefid));
			if(match(Semicolon,p)) return 1;
		}
		return 	reject(&p0,p);
	Endfn
}
//declaration-list:
//        declaration
//        declaration-list declaration
int declaration_list(pos *p){
	if(declaration(p)){
		while(1){
			if(declaration(p)) continue;
			else return 1;
		}
	}
	return 0;
}
//function-specifier:
//        "inline"
int function_specifier(pos *p){
	if(match(Inline,p)) return 1;
	return 0;
}
//typedef-name:
//        identifier
int typedef_name(pos *p){
	Beginfn
		iddata id;
		id.parsing=typedefinition;
		id.str=0;
		if( identifier(p,&id) ) {///!
			//WE HAVE TO CHECK IF TYPEDEF EXISTS
			//if 1
			//return 1;
			//else
			return reject(&p0,p);
		}
		return 0;
	Endfn
}
//int enumeration_constant(info *i);
//enumerator:
//        enumeration-constant
//        enumeration-constant "=" constant-expression
int enumerator(pos *p,iddata *id){
	Beginfn
		if(identifier(p,id)){
			advance(&p0,p);
				if(match(Eq,p)){
					if(constant_expression(p,id)) return 1;
				}
			resetpos(&p0,p);
			return 1;
		}	
		return reject(&p0,p);
	Endfn
}
//enumerator-list:
//        enumerator
//        enumerator-list "," enumerator
int enumerator_list(pos *p,iddata *id){
	Beginfn
		if(enumerator(p,id)){
			while(1){
				advance(&p0,p);
				if(match(Comma,p)){
					if(enumerator(p,id)) continue;	
				}
				resetpos(&p0,p);
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//enum-specifier:
//        "enum" identifier? "{" enumerator-list "}"
//        "enum" identifier? "{" enumerator-list "," "}"
//        "enum" identifier
int enum_specifier(pos *p){
	Beginfn
		iddata id;
		int identifierrecog=0;
		id.parsing=enumdef;
		id.str=0;
		if(match(Enum,p)){
			if(identifier(p,&id)) identifierrecog=1;
			Begin
				if(match(CBraOpen,p)){
					if(enumerator_list(p,&id)){
						if(match(Comma,p));
						if(match(CBraClose,p)) return 1;
					}
				}
			End
			if(identifierrecog) return 1;
		}
		return reject(&p0,p);
	Endfn
}
//identifier-list:
//        identifier
//        identifier-list "," identifier
int identifier_list(pos *p,iddata *id){
	Beginfn
		if(identifier(p,id)){
			while(1){
				advance(&p0,p);
				if(match(Comma,p)){
						if(identifier(p,id)) continue;
				}
				else 1;
				resetpos(&p0,p);
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//assignment-operator:
//        "="
//        "*="
//        "/="
//        "%="
//        "+="
//        "-="
//        "<<="
//        ">>="
//        "&="
//        "^="
//        "|="
const char * assignment_operator(pos *p){
	if(match(Eq,p)) return Eq;
	else if(match(MulEq,p)) return MulEq;
	else if(match(DivEq,p)) return DivEq;
	else if(match(ModEq,p)) return ModEq;
	else if(match(PlusEq,p)) return PlusEq;
	else if(match(MinusEq,p)) return MinusEq;
	else if(match(LtLtEq,p)) return LtLtEq;
	else if(match(GtGtEq,p)) return GtGtEq;
	else if(match(AndEq,p)) return AndEq;
	else if(match(XorEq,p)) return XorEq;
	else if(match(OrEq,p)) return OrEq;
	else return 0;
}
//unary-operator:
//        "&"
//        "*"
//        "+"
//        "-"
//        "~"
//        "!"
int unary_operator(pos *p){
	if(match(And,p)) return 1;
	else if(match(Mul,p)) return 1;
	else if(match(Plus,p)) return 1;
	else if(match(Minus,p)) return 1;
	else if(match(Tilde,p)) return 1;
	else if(match(Not,p)) return 1;
	else return 0;
}
int assignment_expression(pos *p,iddata *id);
int initializer_list(pos *p,iddata *id);
//initializer:
//        assignment-expression
//        "{" initializer-list "}"
//        "{" initializer-list "," "}"
int initializer(pos *p,iddata *id){
	Beginfn
		if(assignment_expression(p,id)) return 1;
		else if(match(CBraOpen,p)){
			if(initializer_list(p,id)){
				if(match(Comma,p));
				if(match(CBraClose,p)) return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
int conditional_expression(pos *p,iddata *id);
//constant-expression:
//       conditional-expression
int constant_expression(pos *p,iddata *id){
	return conditional_expression(p,id);
}
//designator:
 //       "[" constant-expression "]"
 //       "." identifier
int designator(pos *p,iddata *id){
	Beginfn
		if(match(SBraOpen,p)){
			if(constant_expression(p,id)){
				if(match(SBraClose,p)) return 1;
			}
		}
		else if(match(Dot,p)){
			if(identifier(p,id)) return 1;
		}
		return reject(&p0,p);
	Endfn
}
//designator-list:
//        designator
//        designator-list designator
int designator_list(pos *p,iddata *id){
	if(designator(p,id)){
		while(1){
			if(designator(p,id)) continue;
			else return 1;
		}
	}
	return 0;
}
//designation:
//        designator-list "="
int designation(pos *p,iddata *id){
	Beginfn
		if(designator_list(p,id)){
			if(match(Eq,p)) return 1;
		}
		return 	reject(&p0,p);
	Endfn
}
//initializer-list:
// designation? initializer
//        initializer-list "," designation? initializer
int initializer_list(pos *p,iddata *id){
	Beginfn
		if(designation(p,id));
		if(initializer(p,id)){
			while(1){
				advance(&p0,p);
				if(match(Comma,p)){
					if(designation(p,id));
					if(initializer(p,id)) continue;
				}
				else return 1;
				resetpos(&p0,p);
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
int abstract_declarator(pos *p,iddata *id);
//parameter-declaration:
//        declaration-specifiers declarator
//        declaration-specifiers abstract-declarator?
int parameter_declaration(pos *p){
	Beginfn
		iddata parameterid;
		parameterid.parsing=parameter;
		parameterid.str=0;
		if(declaration_specifiers(p)){
			if(declarator(p,&parameterid)) {
				emit(p,PAR);//0
				if(!handledef(p,1,&parameterid)) {			
					return reject(&p0,p);
				}
				//ksksks todo same things like after def
				return 1;
			}
			if(abstract_declarator(p,&parameterid));
			return 1;
		}
		return reject(&p0,p);
	Endfn
}
void adjustParametersInISP(pos *p){//this function puts the paramters to the right position
	ptrdiff offset=((p->BP.ptr-p->SP.ptr));
	Identinfo* ISP2=p->ISP;
	p->i->offsetforlocals=0;
	p->SP=p->BP;
	while(ISP2<=p->IBP) {
		ISP2->identptr.Str+=offset+SIZEOFPTR+SIZEOFPTR;
		++ISP2;
	}
}
//parameter-list:
//        parameter-declaration
//        parameter-list "," parameter-declaration
int parameter_list(pos *p){
	Beginfn
		int cnt=0;
		p->i->offsetforlocals=0;
		p->i->paramcnt=0;
		if(parameter_declaration(p)){
			++cnt;
			while(1){
				advance(&p0,p);
				if(match(Comma,p)){
					if(parameter_declaration(p)) {
						++cnt;
						continue;
					}
				}
				else{
					p->i->paramcnt=cnt;
					if(p->i->in_function_definition) adjustParametersInISP(p);//TODO in forward functiondef we get error here because this should not be called
					else printf("warning in adjustParameterscall due to forward declaration.\n");
					return 1;
				}
				resetpos(&p0,p);
				p->i->paramcnt=cnt;
				if(p->i->in_function_definition) adjustParametersInISP(p);//TODO in forward functiondef we get error here because this should not be called
				else printf("warning in adjustParameterscall due to forward declaration.\n");
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//parameter-type-list:
//        parameter-list
//        parameter-list "," "..."
int parameter_type_list(pos *p,iddata *id){
	Beginfn
		if(parameter_list(p)){
			advance(&p0,p);
				if(match(Comma,p)){
					if(match(DotDotDot,p)) return 1;
				}
			resetpos(&p0,p);
			return 1;
		}
		return reject(&p0,p);;
	Endfn
}
int type_qualifier_list(pos *p);
//direct-abstract-declarator:
//        "(" abstract-declarator ")"
//        direct-abstract-declarator? "[" type-qualifier-list? assignment-expression? "]"
//        direct-abstract-declarator? "[" "static" type-qualifier-list? assignment-expression "]"
//        direct-abstract-declarator? "[" type-qualifier-list "static" assignment-expression "]"
//        direct-abstract-declarator? "[" "*" "]"
//        direct-abstract-declarator? "(" parameter-type-list? ")"
int direct_abstract_declarator(pos *p,iddata *id){
	Beginfn
		int abstractdeclrecog=0,otherrecog=0;
		do{//"(" abstract-declarator ")"
			Begin
				if(match(BraOpen,p)){
					if(abstract_declarator(p,id)){
						if(match(BraClose,p)) {abstractdeclrecog=1;advance(&p0,p);break;}
					}
				}
			End
		}while(0);
		while(1){
			Begin
				if(match(SBraOpen,p)){
					Begin//direct-abstract-declarator? "[" type-qualifier-list? assignment-expression? "]"
						if(type_qualifier_list(p));
						if(assignment_expression(p,id));
						if(match(SBraClose,p)) {otherrecog=1;advance(&p0,p);continue;}
						resetpos(&p0,p);
						if(match(Static,p)){
							if(type_qualifier_list(p));
							if(assignment_expression(p,id)){
								if(match(SBraClose,p)) {otherrecog=1;advance(&p0,p);continue;}
							}
						}
						resetpos(&p0,p);
						if(type_qualifier_list(p)){
							if(match(Static,p)){
								if(assignment_expression(p,id)){
									if(match(SBraClose,p)){otherrecog=1;advance(&p0,p);continue;}
								}
							}
						}
						resetpos(&p0,p);
						if(match(Mul,p)){
							if(match(SBraClose,p)){otherrecog=1;advance(&p0,p);continue;}
						}
					End
				}
				else if(match(BraOpen,p)){
					if(parameter_type_list(p,id));
					if(match(BraClose,p)) {otherrecog=1;advance(&p0,p);continue;}
				}
				else{advance(&p0,p);break;}
			End
			break;
		};
		if(abstractdeclrecog || otherrecog) return 1;		
		return reject(&p0,p);
	Endfn
}
int pointer(pos *p);
//abstract-declarator:
//       pointer
//        pointer? direct-abstract-declarator
int abstract_declarator(pos *p,iddata *id){
	Beginfn
		int pointerrecog=0;
		if(pointer(p)) pointerrecog=1;
		if(direct_abstract_declarator(p,id)) return 1;
		if(pointerrecog) return 1;
		return reject(&p0,p);
	Endfn
}
int specifier_qualifier_list(pos *p);
//type-name:
//        specifier-qualifier-list abstract-declarator?
int type_name(pos *p,iddata *id){
	Beginfn
		if(specifier_qualifier_list(p)){
			if(abstract_declarator(p,id));
			return 1;
		}
		return reject(&p0,p);
	Endfn
}
//argument-expression-list:
//        assignment-expression
//        argument-expression-list "," assignment-expression
int argument_expression_list(pos *p){
	Beginfn
		int cnt=0;
		iddata varsetid;
		varsetid.parsing=varset;
		varsetid.str=0;
		if(assignment_expression(p,&varsetid)){
			emitPUSH(p);++cnt;
			while(1){
				advance(&p0,p);
					if(match(Comma,p)){
						if(assignment_expression(p,&varsetid)){
							emitPUSH(p);
							++cnt;
							continue;
						}
					}
					else return cnt;
				resetpos(&p0,p);
				return cnt;
			}
		}
		return reject(&p0,p);
	Endfn
}
//expression:
//        assignment-expression
//        expression "," assignment-expression
int expression(pos *p,iddata *id){
	Beginfn
		if(assignment_expression(p,id)){
			while(1){
				advance(&p0,p);
				if(match(Comma,p)){
					if(assignment_expression(p,id)) continue;
				}
				else return 1;
				resetpos(&p0,p);
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//primary-expression:
//        identifier
//        constant
//        string-literal
//        "(" expression ")"
int primary_expression(pos *p,iddata *id){
	Beginfn
		info *i=p->i;
		//*id=0;
		if(identifier(p,id)){
			Identinfo *idinfo=searchhash(i,id);
			if(id->parsing==varget || id->parsing==adrget /*&& id->parsing!=parsetype::varset*/){
				
				if(idinfo==0){
					if((p->c>=i->errpos)&& (4>=i->errprio)){
						static char *err="Unknown identifier:\n";
						i->err=err;
						i->errprio=4;
						i->errpos=p->c;
						i->errtoken=id->str;
					}
					return reject(&p0,p);
				}
				if(idinfo->identtype==varglob){
					i->type=idinfo->type;//ksksksks 
					if(id->parsing==varget) emitGETG(p,id);//4
					else {
						emit(p,PTRG) ;//adrget
						i->type.ptrcnt++;
					}
					emitptr(p,idinfo->identptr.Pu);//4
					i->currentvar=idinfo->identptr.Pu;
					i->currenttype=i->type;
					i->type=i->currenttype;
					i->currentvarglobal=1;
					i->currentcall=0;
				}
				else if(idinfo->identtype==varloc){
					i->type=idinfo->type;//ksksksks 
					if(id->parsing==varget) emitGETL(p,id);//4
					else{
						emit(p,PTRL);
						i->type.ptrcnt++;
					}
					emitptr(p,idinfo->identptr.Pu);//4
					i->currentvar=idinfo->identptr.Pu;
					i->currenttype=i->type;
					i->type=i->currenttype;
					i->currentvarglobal=0;
					i->currentcall=0;
				}
				else if (idinfo->identtype==fn){//4
					i->currentcall=idinfo->identptr.Pu;
					i->type=idinfo->type;
					p->functionIdentinfo=idinfo;
				}
				else{
					if((p->c>=i->errpos) && (3>=i->errprio)){
						static char *err="Unknown use of identifier:\n";
						i->err=err;
						i->errprio=3;
						i->errpos=p->c;
						i->errtoken=id->str;
					}
					return reject(&p0,p);
				}
			}
			//varset
			if(idinfo && id->parsing==varset ) i->type=idinfo->type;//ksksksks 
			return 1;
		}
		else if(hexconstant(p)) return 1;
		else if(octconstant(p)) return 1;
		else if(doubleconstant1(p)) return 1;
		else if(doubleconstant2(p)) return 1;
		else if(intconstant(p))	return 1;
		else if(charconstant(p)) return 1;
		else if(stringliteral(p)) return 1;
		else if(match(BraOpen,p)){
			if(expression(p,id)){
				if(match(BraClose,p)){							
					return 1;
				}
			}
		}
		return reject(&p0,p);
	Endfn
}
int unary_expression(pos *,iddata*);

void composestring(char *start,char *stop,char **result){
	while(start!=stop){
		**result=*start;
		(*result)++;
		start++;
	}
}
//postfix-expression:
//        primary-expression
//        postfix-expression "[" expression "]"
//        postfix-expression "(" argument-expression-list? ")"
//        postfix-expression "." identifier
//        postfix-expression "->" identifier
//        postfix-expression "++"
//        postfix-expression "--"
//        "(" type-name ")" "{" initializer-list "}"
//        "(" type-name ")" "{" initializer-list "," "}"
int postfix_expression(pos *p,iddata *id){
	Beginfn
		info *i=p->i;
		pos startpos=*p;
		char *endpos;
		char *startexpression;
		char *endexpression;
		int j;
		u* currentcall=0;
		Identinfo *functionIdentinfo;
		TYPE rettype;
		i->currentcall=0;
		do{
			if(primary_expression(p,id)) {
				currentcall=i->currentcall;
				rettype=i->type;
				functionIdentinfo=p->functionIdentinfo;
				break;
			}
			else if(match(BraOpen,p)){
				if(type_name(p,id)){
					if(match(BraClose,p)){
						if(match(CBraOpen,p)){
							if(initializer_list(p,id)){
								if(match(Comma,p));
								if(match(CBraClose,p)) break;
							}
						}
					}
				}
			}
			return reject(&p0,p);
		}while(0);
		while(1){
			Begin
				endpos=p->c;
				if(match(SBraOpen,p)){//ssssssssss here we have p[..] should become *(p+....)
					startexpression=p->c;
					if(expression(p,id)){
						endexpression=p->c;
						if(match(SBraClose,p)) {//we translate x[n] to *(x+n)
							char *c=p->c;
							char *cnext=p->cnext;
							int ret;
							int neednewlookup=p->neednewlookup;
							char s[100]="*(";
							char *ss=&s[2];
							advance(&p0,p);
							*p=startpos;
							composestring(startpos.c,endpos,&ss);
							*ss='+';++ss;
							composestring(startexpression,endexpression,&ss);
							*ss=')';++ss;
							ret=emitexpression(p,unary_expression,s,id);
							p->c=c;
							p->cnext=cnext;
							p->neednewlookup=neednewlookup;
							continue;
						}
					}
					return reject(&p0,p);
				}
				else if(match(BraOpen,p)){
					int cnt;
					if(!currentcall) return reject(&p0,p);
					if(cnt=argument_expression_list(p));//ksks this is function call
					if(match(BraClose,p)) {
						emit(p,CALL);
						emitptr(p,currentcall);
						if(cnt!=functionIdentinfo[1].identptr.Int){//check amount of parameters
							if((p->c >= i->errpos) &&  (5>=i->errprio)){
								static char err[100];
								sprintf(err,"Function call %s with %d parameters but %d needed.\n",functionIdentinfo[0].identstr,cnt,functionIdentinfo[1].identptr.Int);
								i->errtoken=p->token;
								i->errprio=5;
								i->err=err;
								i->errpos=p->c;
							}
							return reject(&p0,p);
						}
						for(j=1;j<=functionIdentinfo[1].identptr.Int;++j){
							TYPE poptype=((CompileTypeStack*)(p->ISP))->type;
							memptr patchpos=((CompileTypeStack*)(p->ISP))->typecastPC;
							memptr from;
							p->ISP=(Identinfo*)((char*)p->ISP+sizeof(CompileTypeStack));
							switch(poptype.t){//this is the type pushed
							case INT:{
								switch(functionIdentinfo[j+1].type.t){//this is the type of function call
/*
								case INT:	break;
								case FLOAT:	from=p->PC;emit(p,INT2FLOAT);emit(p,PUSHFLOAT);copyops(p,from,patchpos);break;
								case DOUBLE:from=p->PC;emit(p,INT2DOUBLE);emit(p,PUSHDOUBLE);copyops(p,from,patchpos);break;
*/								case INT:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));	break;
								case FLOAT:	patch(INT2FLOAT,&(patchpos.Pu->VoidfnArr[0]));patch(PUSHFLOAT,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));break;
								case DOUBLE:patch(INT2DOUBLE,&(patchpos.Pu->VoidfnArr[0]));patch(PUSHDOUBLE,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));	break;

								default:			printf("unknown type POP\n");
								}
								break;
							}
							case FLOAT:{
								switch(functionIdentinfo[j+1].type.t){
/*								case INT:	from=p->PC;emit(p,FLOAT2INT);emit(p,PUSHINT);copyops(p,from,patchpos);break;
								case FLOAT:	break;
								case DOUBLE:from=p->PC;emit(p,FLOAT2DOUBLE);emit(p,PUSHDOUBLE);copyops(p,from,patchpos);	break;
*/
								case INT:		patch(FLOAT2INT,&(patchpos.Pu->VoidfnArr[0]));patch(PUSHINT,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));		break;
								case FLOAT:	killnop(p,&(patchpos.Pu->VoidfnArr[1]));break;
								case DOUBLE:	patch(FLOAT2DOUBLE,&(patchpos.Pu->VoidfnArr[0]));patch(PUSHDOUBLE,&(patchpos.Pu->VoidfnArr[1]));killnop(p,&(patchpos.Pu->VoidfnArr[2]));	break;

								default:			printf("unknown type POP\n");
								}
								break;
							}
							case DOUBLE:{
								switch(functionIdentinfo[j+1].type.t){
								case INT:	from=p->PC;emit(p,DOUBLE2INT);emit(p,PUSHINT);copyops(p,from,patchpos);break;
								case FLOAT:	from=p->PC;emit(p,DOUBLE2FLOAT);emit(p,PUSHFLOAT);copyops(p,from,patchpos);break;
								case DOUBLE: break;
								default:			printf("unknown type POP\n");
								}
								break;
							}
							default:				printf("unknown type\n");
							}
						}
						emit(p,POPN);
						emitint(p,cnt);
						i->type=rettype;
						advance(&p0,p);continue;
					}
					return reject(&p0,p);
				}
				else if(match(Dot,p)){
					if(identifier(p,id)) {advance(&p0,p);continue;}
					return reject(&p0,p);
				}
				else if(match(MinusGt,p)){
					if(identifier(p,id)) {advance(&p0,p);continue;}
					return reject(&p0,p);
				}
				else if(match(PlusPlus,p)){
					TYPE nochange;
					nochange.t=NOCHANGE;
					nochange.ptrcnt=0;
					emitPUSH(p);
					//todo do killnop here
					emitTyped(p,INCCHAR,INCINT,INCFLOAT,INCDOUBLE,INCPTR);
					//ksksksks todo check lvalue use
					if(i->currentvarglobal){
						emitSET(p,i->currenttype,i->currentvar,id->str,id->len,SETGCHAR,SETGINT,SETGFLOAT,SETGDOUBLE,SETGPTR,GETGPTR);
					}
					else{
						emitSET(p,i->currenttype,i->currentvar,id->str,id->len,SETLCHAR,SETLINT,SETLFLOAT,SETLDOUBLE,SETLPTR,GETLPTR);
					}
					emitPOP(p,nochange);
					advance(&p0,p);continue;
				}
				else if(match(MinusMinus,p)){
					TYPE nochange;
					nochange.t=NOCHANGE;
					emitPUSH(p);
					emitTyped(p,DECCHAR,DECINT,DECFLOAT,DECDOUBLE,DECPTR);
					//ksksksks todo check lvalue use
					if(i->currentvarglobal){
						emitSET(p,i->currenttype,i->currentvar,id->str,id->len,SETGCHAR,SETGINT,SETGFLOAT,SETGDOUBLE,SETGPTR,GETGPTR);
					}
					else{
						emitSET(p,i->currenttype,i->currentvar,id->str,id->len,SETLCHAR,SETLINT,SETLFLOAT,SETLDOUBLE,SETLPTR,GETLPTR);
					}
					emitPOP(p,nochange);
					advance(&p0,p);continue;
				}
				else return 1; 
			End
			return 1;
		}
	Endfn
}
int cast_expression(pos *,iddata *id);
//unary-expression:
//        postfix-expression
//        "++" unary-expression
//        "--" unary-expression
//        unary-operator cast-expression
//        "sizeof" unary-expression
//        "sizeof" "(" type-name ")"
int unary_expression(pos *p,iddata *id){
	Beginfn
		const char *lastmatch=0;
		int cnt=0;
		while(1){
			if(match(PlusPlus,p)) {
				lastmatch=PlusPlus;
				cnt++;
				continue;
			}
			else if(match(MinusMinus,p)) {
				lastmatch=MinusMinus;
				cnt--;
				continue;
			}
			else if(match(Sizeof,p)) {lastmatch=Sizeof;continue;}
			else break;
		}
		if(lastmatch==Sizeof){
			Begin
				iddata typeidentifier;
				typeidentifier.parsing=typedefinition;
				typeidentifier.str=0;
				if(match(BraOpen,p)){
					if(type_name(p,&typeidentifier)){
						if(match(BraClose,p)) return 1;
					}
				}
			End
		}
		if(postfix_expression(p,id)) {
			if(cnt!=0){
				if(cnt==1) emitTyped(p,INCCHAR,INCINT,INCFLOAT,INCDOUBLE,INCPTR);
				else if(cnt==-1) emitTyped(p,INCCHAR,DECINT,DECFLOAT,DECDOUBLE,DECPTR);
				else{
					emitPUSH(p);
					emit(p,CONST_INT);
					emitint(p,cnt);
					emitTypeCastedOp(p,ADDCHAR,ADDINT,ADDFLOAT,ADDDOUBLE,ADDPTR);
				}
				//ksksksks todo check lvalue use
				if(p->i->currentvarglobal){
					emitSET(p,p->i->currenttype,p->i->currentvar,id->str,id->len,SETGCHAR,SETGINT,SETGFLOAT,SETGDOUBLE,SETGPTR,GETGPTR);
				}
				else{
					emitSET(p,p->i->currenttype,p->i->currentvar,id->str,id->len,SETLCHAR,SETLINT,SETLFLOAT,SETLDOUBLE,SETLPTR,GETLPTR);
				}
			}
			return 1;
		}
		else if(unary_operator(p)){
			const char *unaryop=p->token;

			if(unaryop==And) {
				iddata adrgetid;
				adrgetid.parsing=adrget;
				adrgetid.str=0;
				if(cast_expression(p,&adrgetid)){
					return 1;
				}
				return reject(&p0,p);
				
			}
			else if(unaryop==Mul){
				int getptremitedbak=p->getptremited;
				int getptremited;
				int cast_expression_ok;
				p->getptremited=0;
				cast_expression_ok=cast_expression(p,id);
				getptremited=p->getptremited;
				p->getptremited=getptremitedbak;
				if(cast_expression_ok) {
					if(getptremited==0) {//ssssss
						Identinfo *idinfo;
						if(p->i->global) emitGETG(p,id);
						else emitGETL(p,id);
						idinfo=searchhash(p->i,id);
						if(id==0) return reject(&p0,p);
						emitptr(p,idinfo->identptr.Pu);
					}
					p->i->type.ptrcnt--;
					if(p->i->type.ptrcnt<0) return reject(&p0,p);
					if(id->parsing==varget){
						if(p->i->type.ptrcnt==0) emitTyped(p,DEREFCHAR,DEREFINT,DEREFFLOAT,DEREFDOUBLE,DEREFPTR);
						else emitTyped(p,DEREFPTR,DEREFPTR,DEREFPTR,DEREFPTR,DEREFPTR);//TODO check if last DEREFPTR makes sense
					}
					return 1;
				}
				return reject(&p0,p);
				
			}
			else if(cast_expression(p,id)) {
				if(unaryop==Plus);
				else if(unaryop=Minus) {
					if(p->i->type.t==VOID) return reject(&p0,p);
					else emitTyped(p,NEGCHAR,NEGINT,NEGFLOAT,NEGDOUBLE,0);//3
				}
				else if(match(Tilde,p));
				else if(match(Not,p)) emit(p,NOT);
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}	
//cast-expression:
//        unary-expression
//        "(" type-name ")" cast-expression
int cast_expression(pos *p,iddata *id){
	Beginfn
		while(1){
				if(match(BraOpen,p)){
					iddata typeidentifier;
					typeidentifier.parsing=typedefinition;
					typeidentifier.str=0;
					if(type_name(p,&typeidentifier)){
						if(match(BraClose,p)) {advance(&p0,p);continue;}
					}
				}
			resetpos(&p0,p);
			break;
		}
		if(unary_expression(p,id)) return 1;
		return reject(&p0,p);
	Endfn
}
//multiplicative-expression:
//        cast-expression
//        multiplicative-expression "*" cast-expression
//        multiplicative-expression "/" cast-expression
//        multiplicative-expression "%" cast-expression
int multiplicative_expression(pos *p,iddata *id){
	Beginfn
		if(cast_expression(p,id)){
			while(1){
				if(match(Mul,p)){
					emitPUSH(p);//7
					if(cast_expression(p,id)) emitTypeCastedOp(p,MULCHAR,MULINT,MULFLOAT,MULDOUBLE,0);//7
					else break;
				}
				else if(match(Div,p)){//7
					if(cast_expression(p,id)) emitTypeCastedOp(p,DIVCHAR,DIVINT,DIVFLOAT,DIVDOUBLE,0);//7
					else break;
				}
				else if(match(Mod,p)){
					if(cast_expression(p,id));
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//additive-expression:
//        multiplicative-expression
//        additive-expression "+" multiplicative-expression
//        additive-expression "-" multiplicative-expression
int additive_expression(pos *p,iddata *id){
	Beginfn
		if(multiplicative_expression(p,id)){
			while(1){
				if(match(Plus,p)){
					emitPUSH(p);
					if(multiplicative_expression(p,id)) 
						emitTypeCastedOp(p,ADDCHAR,ADDINT,ADDFLOAT,ADDDOUBLE,ADDPTR);//6
					else break;
				}
				else if(match(Minus,p)){
					emitPUSH(p);
					if(multiplicative_expression(p,id)) 
						emitTypeCastedOp(p,SUBCHAR,SUBINT,SUBFLOAT,SUBDOUBLE,SUBPTR);//6
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//shift-expression:
//        additive-expression
//        shift-expression "<<" additive-expression
//        shift-expression ">>" additive-expression
int shift_expression(pos *p,iddata *id){
	Beginfn
		if(additive_expression(p,id)){
			while(1){
				if(match(LtLt,p)){
					if(additive_expression(p,id));
					else break;
				}
				else if(match(GtGt,p)){
					if(additive_expression(p,id));
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//relational-expression:
//        shift-expression
//        relational-expression "<" shift-expression
//        relational-expression ">" shift-expression
//        relational-expression "<=" shift-expression
//        relational-expression ">=" shift-expression
int relational_expression(pos *p,iddata *id){
	Beginfn
		if(shift_expression(p,id)){
			while(1){
				 if(match(LtEq,p)){
					emitPUSH(p);
					if(shift_expression(p,id)) emitTypeCastedOp(p,LTEQCHAR,LTEQINT,LTEQFLOAT,LTEQDOUBLE,LTEQPTR);
					else break;
				}
				else if(match(GtEq,p)){
					emitPUSH(p);
					if(shift_expression(p,id)) emitTypeCastedOp(p,GTEQCHAR,GTEQINT,GTEQFLOAT,GTEQDOUBLE,GTEQPTR);
					else break;
				}
				else if(match(Lt,p)){
					emitPUSH(p);
					if(shift_expression(p,id))	emitTypeCastedOp(p,LTCHAR,LTINT,LTFLOAT,LTDOUBLE,LTPTR);
					else break;
				}
				else if(match(Gt,p)){
					emitPUSH(p);
					if(shift_expression(p,id)) emitTypeCastedOp(p,GTCHAR,GTINT,GTFLOAT,GTDOUBLE,GTPTR);
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}

//equality-expression:
//        relational-expression
//        equality-expression "==" relational-expression
//        equality-expression "!=" relational-expression
int equality_expression(pos *p,iddata *id){
	Beginfn
		if(relational_expression(p,id)){
			while(1){
				if(match(EqEq,p)){
					emitPUSH(p);
					if(relational_expression(p,id)){
						emitTypeCastedOp(p,EQEQCHAR,EQEQINT,EQEQFLOAT,EQEQDOUBLE,EQEQPTR);
					}
					else break;
				}
				else if(match(NotEq,p)){
					emitPUSH(p);
					if(relational_expression(p,id)){
						emitTypeCastedOp(p,NOTEQCHAR,NOTEQINT,NOTEQFLOAT,NOTEQDOUBLE,NOTEQPTR);
					}
					else break;
				}
				else return 1;
			}
		}
		return 	reject(&p0,p);
	Endfn
}
//AND-expression:
//        equality-expression
//        AND-expression "&" equality-expression
int AND_expression(pos *p,iddata *id){
	Beginfn
		if(equality_expression(p,id)){
			while(1){
				if(match(And,p)){
					if(equality_expression(p,id));
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//exclusive-OR-expression:
//        AND-expression
//        exclusive-OR-expression "^" AND-expression
int exclusive_OR_expression(pos *p,iddata *id){
	Beginfn
		if(AND_expression(p,id)){
			while(1){
				if(match(Xor,p)){
					if(AND_expression(p,id));
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//inclusive-OR-expression:
//        exclusive-OR-expression
//        inclusive-OR-expression "|" exclusive-OR-expression
int inclusive_OR_expression(pos *p,iddata *id){
	Beginfn
		if(exclusive_OR_expression(p,id)){
			while(1){
				if(match(Or,p)){
					if(exclusive_OR_expression(p,id));
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//logical-AND-expression:
//        inclusive-OR-expression
//        logical-AND-expression "&&" inclusive-OR-expression
int logical_AND_expression(pos *p,iddata *id){
	Beginfn
		if(inclusive_OR_expression(p,id)){
			while(1){
				if(match(AndAnd,p)){
					if(inclusive_OR_expression(p,id));
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//logical-OR-expression:
//        logical-AND-expression
//        logical-OR-expression "||" logical-AND-expression
int logical_OR_expression(pos *p,iddata *id){
	Beginfn
		if(logical_AND_expression(p,id)){
			while(1){
				if(match(OrOr,p)){
					if(logical_AND_expression(p,id));
					else break;
				}
				else return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//conditional-expression:
//        logical-OR-expression
//        logical-OR-expression "?" expression ":" conditional-expression
int conditional_expression(pos *p,iddata *id){
	Beginfn
		if(logical_OR_expression(p,id)){
			if(match(Question,p)){
				if(expression(p,id)){
					if(match(Colon,p)){
						if(conditional_expression(p,id)) return 1;
					}
				}
			}
			else return 1;
		}
		return reject(&p0,p);
	Endfn
}
//assignment-expression:
//        conditional-expression
//        unary-expression assignment-operator assignment-expression
int assignment_expression(pos *p,iddata *id){
	Beginfn
		info *i=p->i;
		const char *assignement_operator_token=0;
		iddata varsetid;
		iddata vargetid;
		varsetid.parsing=varset;
		varsetid.str=0;
		vargetid.parsing=varget;
		vargetid.str=0;
		if(unary_expression(p,&varsetid)){
			if(assignement_operator_token=assignment_operator(p)){
				Identinfo *idinfo=searchhash(i,&varsetid);
				if(idinfo==0){
					if((p->c>=i->errpos) && (5>=i->errprio)){
						static char *err="Unknown identifier:\n";
						i->err=err;
						i->errprio=5;
						i->errpos=p->c;
						i->errtoken=varsetid.str;
					}
					return reject(&p0,p);
				}
				if(idinfo->type.ptrcnt>0) emit(p,PUSHPTR);
				if(assignment_expression(p,id)) {
					if(assignement_operator_token==Eq){}
					else{
						emitPUSH(p);
						if(idinfo->identtype==varglob){
							i->type=idinfo->type;
							emitGETG(p,&varsetid);//5
							emitptr(p,idinfo->identptr.Pu);//5
						}
						else if(idinfo->identtype==varloc){
							i->type=idinfo->type;
							emitGETL(p,&varsetid);//5
							emitptr(p,idinfo->identptr.Pu);//5
						}
						if(assignement_operator_token==MulEq){
							emitTypeCastedOp(p,MULCHAR,MULINT,MULFLOAT,MULDOUBLE,0);	
						}
						else if(assignement_operator_token==DivEq){
							emitTypeCastedOp(p,DIVCHAR,DIVINT,DIVFLOAT,DIVDOUBLE,0);
						}
						else if(assignement_operator_token==PlusEq){
							emitTypeCastedOp(p,ADDCHAR,ADDINT,ADDFLOAT,ADDDOUBLE,ADDPTR);
						}
						else if(assignement_operator_token==MinusEq){
							emitTypeCastedOp(p,SUBCHAR,SUBINT,SUBFLOAT,SUBDOUBLE,SUBPTR);
						}
						/*
						else if(assignement_operator_token==ModEq){
							emitTypeCastedOp(i,MODINT,MODFLOAT,MODDOUBLE);
						}
						else if(assignement_operator_token==LtLtEq){
							emitTypeCastedOp(i,SHLINT,SHLFLOAT,SHLDOUBLE);
						}
						else if(assignement_operator_token==GtGtEq){
							emitTypeCastedOp(i,SHRINT,SHRFLOAT,SHRDOUBLE);
						}
						else if(assignement_operator_token==AndEq){
							emitTypeCastedOp(i,ANDINT,ANDFLOAT,ANDDOUBLE);
						}
						else if(assignement_operator_token==XorEq){
							emitTypeCastedOp(i,XORINT,XORFLOAT,XORDOUBLE);
						}
						else if(assignement_operator_token==OrEq){
							emitTypeCastedOp(i,ORINT,ORFLOAT,ORDOUBLE);
						}
						*/
						else{
							printf( "Unknown assignement operator%s\n",assignement_operator_token);//remove this line if we have all the others implemented
							return reject(&p0,p);
						}
					}
					if(idinfo->identtype==varglob){
						emitSET(p,idinfo->type,idinfo->identptr.Pu,idinfo->identstr,idinfo->len,SETGCHAR,SETGINT,SETGFLOAT,SETGDOUBLE,SETGPTR,GETGPTR);//5
					}
					else if(idinfo->identtype==varloc){
						emitSET(p,idinfo->type,idinfo->identptr.Pu,idinfo->identstr,idinfo->len,SETLCHAR,SETLINT,SETLFLOAT,SETLDOUBLE,SETLPTR,GETLPTR);//5
					}
					else{
						if((p->c>=i->errpos)&& (5>=i->errprio)){
							static char *err="Unknown use of identifier:\n";
							i->err=err;
							i->errprio=5;
							i->errpos=p->c;
							i->errtoken=varsetid.str;
						}
						return reject(&p0,p);
					}
					if(id->parsing==varget) {
						*id=varsetid;
						id->parsing=varget;
					}
					return 1;
				}
			}
		}
		resetpos(&p0,p);
		if(conditional_expression(p,&vargetid)) {
			if(id->parsing==varget) *id=vargetid;
			if(id->parsing==varset) *id=varsetid;
			return 1;
		}
		return reject(&p0,p);
	Endfn
}
//direct-declarator:
// 1       identifier
// 2       "(" declarator ")"
// 3       direct-declarator "[" type-qualifier-list? assignment-expression? "]"
// 4       direct-declarator "[" "static" type-qualifier-list? assignment-expression "]"
// 5       direct-declarator "[" type-qualifier-list "static" assignment-expression "]"
// 6       direct-declarator "[" type-qualifier-list? "*" "]"
// 7       direct-declarator "(" parameter-type-list ")"
// 8       direct-declarator "(" identifier-list? ")"
int direct_declarator(pos *p,iddata *id){
	Beginfn
		int num=0;
		do{
			if(identifier(p,id)){
				num=1;
				break;
			}
			else if (match(BraOpen,p)){
				if(declarator(p,id)){
					if(match(BraClose,p)){
						num=2;
						break;
					}
				}
			}
			return reject(&p0,p);
		}while(0);
		while(1){
			if(match(SBraOpen,p)){
				Begin
					//  direct-declarator "[" type-qualifier-list? assignment-expression? "]"
					if(type_qualifier_list(p));
					if(assignment_expression(p,id)){
						int uu=1;
						uu++;
					}
					if (match(SBraClose,p)) {
						num=3;
						advance(&p0,p);continue;
					}
					resetpos(&p0,p);
					//direct-declarator "[" "static" type-qualifier-list? assignment-expression "]"
					if(match(Static,p)){
						if(type_qualifier_list(p));
						if(assignment_expression(p,id)){
							if(match(SBraClose,p)) {
								num=4;
								advance(&p0,p);continue;
							}
						}
					}
					resetpos(&p0,p);
					//direct-declarator "[" type-qualifier-list "static" assignment-expression "]"
					if(type_qualifier_list(p)){
						if(match(Static,p)){
							if(assignment_expression(p,id)){
								if(match(SBraClose,p)){
									num=5;
									advance(&p0,p);continue;
								}
							}
						}
					}
					//direct-declarator "[" type-qualifier-list? "*" "]"
					resetpos(&p0,p);
					if(type_qualifier_list(p));
					if(match(Mul,p)){
						if(match(SBraClose,p)) {
							num=6;
							advance(&p0,p);continue;
						}
					}
					break;
				End;
			}
			else if(match(BraOpen,p)){
				Begin
					//direct-declarator "(" parameter-type-list ")"
					if(parameter_type_list(p,id)){
						if(match(BraClose,p)) {
							num=7;
							advance(&p0,p);continue;//TODO here we have forward function definition
						}
					}
					//direct-declarator "(" identifier-list? ")"
					resetpos(&p0,p);
					if(identifier_list(p,id));
					else{
						//TODO here we have forward function definition without paramters
						
					}
					if(match(BraClose,p)) {
						num=8;
						advance(&p0,p);continue;
					}
					break;
				End
			}
			else return num;//no BraOpen or SBraOpen
		}
		return reject(&p0,p);
	Endfn
}
int type_qualifier(pos *);
//type-qualifier-list:
//        type-qualifier
//        type-qualifier-list type-qualifier
int type_qualifier_list(pos *p){
	if(type_qualifier(p)){
		while(type_qualifier(p));
		return 1;
	}
	return 0;
}        
//pointer:
//        "*" type-qualifier-list?
//        "*" type-qualifier-list? pointer
int pointer(pos *p){
	p->i->type.ptrcnt=0;
	if(match(Mul,p)){
		p->i->type.ptrcnt++;
		if(type_qualifier_list(p));
		while(match(Mul,p)){
			p->i->type.ptrcnt++;
			if(type_qualifier_list(p));
		}
		return 1;
	}
	return 0;	
}
//declarator:
//       pointer? direct-declarator
int declarator(pos *p,iddata *id){
	Beginfn
		int num;
		if(pointer(p));
		if(num=direct_declarator(p,id)){
			if(num==3) p->i->type.ptrcnt++;//we have int a[100]
			return num;
		}
		return reject(&p0,p);
	Endfn
}
//struct-declarator:
//       declarator
//        declarator? ":" constant-expression
int struct_declarator(pos *p){
	Beginfn
		int declaratorsupplied=0,constantexpressionsupplied=0;
		iddata id;
		id.parsing=structdef;
		id.str=0;
		if(declarator(p,&id)) declaratorsupplied=1;
		if(match(Colon,p)){
			if(constant_expression(p,&id)) constantexpressionsupplied=1;
		}
		if(constantexpressionsupplied) return 1;
		else if(declaratorsupplied) return 1;
		else return reject(&p0,p);
	Endfn
}
//struct-declarator-list:
//        struct-declarator
//        struct-declarator-list "," struct-declarator
int struct_declarator_list(pos *p){
	Beginfn
		if(struct_declarator(p)){
			while(1){
				advance(&p0,p);
				if(match(Comma,p)){
					if(struct_declarator(p));
					else {return reject(&p0,p);}
				}
				else return 1;
				resetpos(&p0,p);
				return 1;
			}
		}
		return reject(&p0,p);
	Endfn
}
//type-qualifier:
//        "const"
//        "restrict"
//        "volatile"
int type_qualifier(pos *p){
	if(match(Const,p)) return 1;
	else if(match(Restrict,p)) return 1;
	else if(match(Volatile,p)) return 1;
	return 0;
}
int type_specifier(pos *p);
//specifier-qualifier-list:
//        type-specifier specifier-qualifier-list?
//        type-qualifier specifier-qualifier-list?
int specifier_qualifier_list(pos *p){
	if(type_specifier(p)){
		if(specifier_qualifier_list(p));
		return 1;
	}
	else if(type_qualifier(p)){
		if(specifier_qualifier_list(p));
		return 1;
	}
	return 0;
}
//struct-declaration:
//        specifier-qualifier-list struct-declarator-list ";"
int struct_declaration(pos *p){
	Beginfn
		if(specifier_qualifier_list(p)){
			if(struct_declarator_list(p)){
				if(match(Semicolon,p)) return 1;
			}
		}	
		return reject(&p0,p);;
	Endfn
}
//struct-declaration-list:
//        struct-declaration
//        struct-declaration-list struct-declaration
int struct_declaration_list(pos *p){
	if(struct_declaration(p)){
		while(struct_declaration(p));
		return 1;
	}
	return 0;
}
//struct-or-union:
//        "struct"
//        "union"
int struct_or_union(pos *p){
	if(match(Struct,p)) return structdef;
	else if(match(Union,p)) return uniondef;	
	return 0;
}
//struct-or-union-specifier:
//        struct-or-union identifier? "{" struct-declaration-list "}"
//        struct-or-union identifier
int struct_or_union_specifier(pos *p){
	Beginfn
		int identifiersupplied=0,structdecllistsupplied=0;
		iddata id;
		id.str=0;
		if(id.parsing=(parsetype)struct_or_union(p)){
			if(identifier(p,&id)) identifiersupplied=1;
			if(match(CBraOpen,p)){
				if(struct_declaration_list(p)){
					if(match(CBraClose,p)) structdecllistsupplied=1;				
				}
			}
			if( structdecllistsupplied) return 1;
			else if(identifiersupplied ) return 1;
			else return reject(&p0,p);
		}
		return reject(&p0,p);
	Endfn
}
//type-specifier:
//        "void"
//        "char"
//        "short"
//        "int"
//        "long"
//        "float"
//        "double"
//        "signed"
//        "unsigned"
//        "_int"
//        "_Complex"
//        struct-or-union-specifier
//        enum-specifier
//       typedef-name
int type_specifier(pos *p){
	if(match(Void,p)) return 1;
	else if(match(Char,p))return 1;
	else if(match(Short,p))return 1;
	else if(match(Int,p)) return 1;
	else if(match(Long,p)) return 1;
	else if(match(Float,p)) return 1;
	else if(match(Double,p)) return 1;
	else if(match(Signed,p)) return 1;
	else if(match(Unsigned,p)) return 1;
	else if(match(_int,p)) return 1;
	else if(match(_COmplex,p)) return 1;
	else if(struct_or_union_specifier(p))return 1; 
	else if(enum_specifier(p))return 1; 
	else if(typedef_name(p))return 1;	
	return 0;
}
//storage-class-specifier:
//        "typedef"
//        "extern"
//        "static"
//        "auto"
//        "register"
int storage_class_specifier(pos *p){
	if(match(Typedef,p)) return 1;
	else if(match(Extern,p)) return 1;
	else if(match(Static,p)) return 1;
	else if(match(Auto,p)) return 1;
	else if(match(Register,p)) return 1;	
	return 0;
}
//declaration-specifiers:
//        storage-class-specifier declaration-specifiers?
//        type-specifier declaration-specifiers?
//        type-qualifier declaration-specifiers?
//        function-specifier declaration-specifiers?
int declaration_specifiers(pos *p){
	Beginfn
		int recog=0;
		while(1){
			if(storage_class_specifier(p));
			else if(type_specifier(p)){//!missing char type
				if(p->token==Void){
					p->i->type.t=VOID;p->i->type.ptrcnt=0;
				}
				else if(p->token==Char){
					p->i->type.t=CHAR;p->i->type.ptrcnt=0;
				}
				else if(p->token==Short){
					p->i->type.t=INT;p->i->type.ptrcnt=0;
				}
				else if(p->token==Int){
					p->i->type.t=INT;p->i->type.ptrcnt=0;
				}
				else if(p->token==Long){
					p->i->type.t=INT;p->i->type.ptrcnt=0;
				}
				else if(p->token==Float){
					p->i->type.t=FLOAT;p->i->type.ptrcnt=0;
				}
				else if(p->token==Double){
					p->i->type.t=DOUBLE;p->i->type.ptrcnt=0;
				}
				else
					printf("unsupported type\n");
			}
			else if(type_qualifier(p));
			else if(function_specifier(p));
			else break;
			recog=1;
		}
		if(!recog) return reject(&p0,p);
		return 1;
	Endfn
}
//function-definition:
//        declaration-specifiers declarator declaration-list? compound-statement
int function_definition(pos *p){
	Beginfn
		info *i=p->i;
		memptr jmppos1, PCfn;
		int num;
		int cnt,paramcnt;
		iddata functionid;
		i->in_function_definition=1;
		i->global=0;
		functionid.parsing=functionname;
		functionid.str=0;
		if(declaration_specifiers(p)){
			i->fnrettype=i->type;
			p->BP=p->SP;//
			p->IBP=p->ISP-1;//
			p->ILBP=p->IBP;//
			emit(p,JMP);//
			jmppos1=p->PC;
			emitptrd(p,0);
			PCfn=p->PC;
			emit(p,BEGINFN);
			num=declarator(p,&functionid);
			if((num==7)|| (num==8)){
				if(declaration_list(p));
				i->firstCBraOpenInFn=1;
				{
					Identinfo *ii=searchhash(i,&functionid);
					printdebug("%s ",functionid);//ks todo put into hashtable and functionstack
					if(ii){
						if(ii->identtype==fn) {
							if((p->c>=i->errpos)&& (5>=i->errprio)){
								static char *err="Function definition uses already defined function name\n";
								i->err=err;
								i->errprio=5;
								i->errpos=p->c;
								i->errtoken=functionid.str;
							}
							i->in_function_definition=0;
							return reject(&p0,p);
						}
						if(ii->identtype==varglob) {
							if((p->c>=i->errpos)&& (5>=i->errprio)){
								static char *err="Function definition uses already defined global variable name\n";
								i->err=err;
								i->errprio=5;
								i->errpos=p->c;
								i->errtoken=functionid.str;
							}
							i->in_function_definition=0;
							return reject(&p0,p);
						}
						//ksksktodo type?
					}
					//remove local variables and types
					p->ISP=p->IBP;
					p->ISP-=i->paramcnt;//we keep the parameter types;
					p->ISP->identptr.Int=i->paramcnt;//so we store fn,then cnt,then all parameters in ISP[pos], ISP[pos+1],ISP[pos...]
					p->ISP--;
					if((char*)p->ISP<p->PC.ptr){
						static char *err="Identinfo stack overflow\n";
						i->err=err;
						i->errpos=p->c;
						i->errtoken=0;
						i->in_function_definition=0;
						return reject(&p0,p);
					}
					p->ISP->identstr=functionid.str;
					p->ISP->identtype=fn;
					p->ISP->len=functionid.len;
					p->ISP->identptr.Pu=PCfn.Pu;
					p->ISP->type=i->fnrettype;
					inserthash(i,p->ISP);
					p->IBP=p->ISP-1;//*
					p->ILBP=p->IBP;
					if(compound_statement(p,&functionid)){
						emit(p,ENDFN);
						jmppos1.Pu->ptrd=p->PC.ptr-jmppos1.ptr;
						while(p->ISP<=p->IBP) {//delete all local vars
							removehash(i,p->ISP);
							++p->ISP;
						}
						//now ISP has value from * and points to fn
						//now delete all parameters from hash
						p->IBP=p->ISP;//we store it temporarily
						++p->ISP;
						paramcnt=p->ISP->identptr.Int;//this is amount of params
						++p->ISP;
						for(cnt=0;cnt<paramcnt;++cnt){//we get amount of params;
							removehash(i,p->ISP);
							++p->ISP;
						}
						p->ISP=p->IBP;//restore isp
						p->SP=p->BP;
						i->in_function_definition=0;
						return 1;
					}
				}
			}
		}
		i->in_function_definition=0;
		return reject(&p0,p);
	Endfn
}
//external-declaration:
//        function-definition
//        declaration
int external_declaration(pos *p){
	if(function_definition(p)) return 1;
	else{
		Begin
		
			p->i->global=1;
			
			if(declaration(p)) return 1;
		End
	}
	return 0;
}
//translation-unit:
//        external-declaration
//        translation-unit external-declaration
//sparray=p->SP.ptr;
//			//emitexpression(p,declaration,"int SPARRAY$=99;");//there is one SPARRAY per block. It stores the position of the first new place onstack for arrays. on entry in new block. BP and SP is set to sparray. and SPARRAY is set to stack position upon block exit assuming that each array is a pointer. each array alloc decrements sparray. upon block exit SPARRAY is set to BP. BP and SP are poped from stack.
//			emit(p,PUSHN);
//			patchpos=p->PC;//to d
//			emitint(p,0);
//			if(block_item_list(p));
//			patchpos.Pu->Int=sparray-p->SP.ptr;//correction factor for arrays on stack

int translation_unit(pos *p){
	Beginfn
		char *sparray=p->SP.ptr;
		memptr patchpos;
		emit(p,PUSHN);
		patchpos=p->PC;
		emitint(p,0);
		while(external_declaration(p));
		space(p);
		if(*(p->c)==0){
			iddata id;
			char fn[]="main";
			Identinfo *uu;
			id.str=fn;
			id.len=4;
			id.idinfo=0;
			uu=searchhash(p->i,&id);
			patchpos.Pu->Int=sparray-p->SP.ptr;
			emit(p,ENDP);
			emit(p,CALL);
			if(uu) emitptr(p,uu->identptr.Pu);
			else{
				static char *err="Missing main function\n";
				p->i->err=err;
				p->i->errpos=0;
				p->i->errtoken=0;
				return reject(&p0,p);
			}
			emit(p,ENDP);
			return 1;
		}
		return reject(&p0,p);
	Endfn
}
int fib3(int n) {
    int a,b,neu;
    int zaehler;
    if (n<=2) return 1;
    a = 1;
    b = 1;
    for (zaehler=3; zaehler<=n; ++zaehler){
        neu = a+b;
        a = b;
        b = neu;
    }
    return neu;
}
int main(int argc, char* argv[]){//the stack points to the return address
#ifdef generatesortedtokenlist
	sorttokenlist();
	while(1);
#else
gentokenlookup();
#endif
	PRINTINT_p();
	printf("sizeofint %d",sizeof(ptrdiff));
	printf("sizeof int %d",sizeof(int));
	
while(1){
	char ss1[1000]="\
int i=9;\
int a=i+3*3;\
int fn(int p){int ux=12;int gn=p;{int ux=ux;}ux;return p+1;}\
int fn2(int a,int b){return a+b;}\
int larissi=fn2(2,3);\
int kili=a;\
void main(void){\
int i=2;\
int n=123;\
int m;\
while(i){\
i=i-1;\
if(0){33;}else{44;}\
if(1){33;}else{44;}\
}\
fn(42);\
m=i=fn(43)*fn(43);\
m;\
a=123;\
a++;\
print(a);\
{\
int j=0;\
j=a;\
print(a);\
m=a;\
}\
}\
";
//error
//while(int x=0){\
//int c=0;\
//};
	char ss2[1000]="\
int fn(int a,int b){\
int a=1;\
int b=2;\
int c=0;\
if(a==b) c=1;\
else c=2;\
return c;}\
int i=fn(1,2);\
void main(void){\
int a;\
for(a=0;a < 10;++ ++a){\
print(a);\
int i=a;\
}\
}";

	char ss4[]="\
int sam=36;\
int kilian=39;\
int sum=0;\
int fn(int a,int b){\
int c;\
print(a);\
print(b);\
for(c=a;c<=b;c++){\
print(c*2);\
}\
return (a+b)*3;\
}\
void main(void){\
int m;\
print(fn(1,3));\
for(m=0;m < 2000;++m){\
print(m*3);\
}\
m=10; \
m*=10;\
print(5-1-2);\
}			  ";
	

char ss[]="\
int i=1;\
int j=2;\
double d=3;\
int fn(int i,double j){\
int uuu;\
return i+j;\
}\
	int fib3(int n) {\
        int a,b,neu;\
        int zaehler;\
        if (n<=2) return 1;\
        a = 1;\
        b = 1;\
        for (zaehler=3; zaehler<=n; zaehler++)\
        {\
                neu = a+b;\
                a = b;\
                b = neu;\
        }\
        return neu;\
}\
int fib4(int n, int a, int b) {\
        if (n==1) return a;\
        if (n==2) return b;\
        return fib4(n-1,b,a+b);\
}\
void main(){\
char cc='a';\
char end='z';\
int m,u=0;\
double f=123.67e-3+11.9;\
print(end);\
for(cc='a';cc<end;cc++) print(cc);\
print(f);\
print(fn(9+i,100));\
print(110);\
for(m=0;m < 10;++m) u+=fib3(1234567+m);\
	print(fib3(1234567));\
	print(u);\
	print(fib3(f));\
	print(fib4(12,1,1));\
	m=0;\
	while(m<5) print(m++);\
	do{print(--m);} while(m>0);\
}";


char sllls[]="\
int i=1;\
int j=2;\
double d=3;\
int fn(int i,double j){\
int uuu;\
return i+j;\
}\
void main(){\
print(fn(9+i,100));\
i=j;\
++i;\
}";

char sdfgdfs[]="\
		  void main(){\
		  int a=42;\
		  int *p=&a;\
		  int **pp=&p;\
		  **pp=33;\
		  print(*(*pp));\
		  }";
char ssddd[]="\
		  void main(){\
		  int a=42;\
		  int b=24;\
		  int *p=&a;\
		  int *pb=&b;\
		  int **pp=&p;\
		  **pp=22;\
		  **pp=33;\
		  *p=44; \
		  print(**pp);\
		   *pp=&pb;\
		   **pp=123;\
		  print(b);\
		  }";
char sssdf[]="\
		  void main(){\
		  int a=42;\
		  int b=24;\
		  int c[10+20];\
		  int *p=&a;\
		  print(&a);\
		  print(&b);\
		  print(*(p--));\
		  *(p+1)=123;\
		  print(*p);\
		  }";
//*c geht nicht *(c) geht
char sseee[]="void main(){\
		  int c[3];\
		  int x=1,b=2;\
		  *(c+(0))=0;\
		  b=x=55;\
		  print(b);\
		  print(x);\
}";
char ssdddd[]="int uuuu=988;\
		  void main(){\
		  int a=42;\
		  int b=24;\
		  int *p=&a;\
		  int *pp=&b;\
		  int xx=888;\
		  int c[a-42+3];\
		  int d[1];\
		  int x=1;\
		  *p=1;\
		  *(p-x)=99;\
		  *(c)=111;\
		  c[x]=222;\
		c[2*x]=333;\
		*d=777;\
		   print(a);\
		   print(b);\
		   print(*(c-2));\
		   print(*(c-1));\
		   print(*d);\
		   print(*c);\
		   print(c[1]);\
		   print(*(c+2));\
		   print(*(c+3));\
			print(*(c+4));\
			print(*(c+5));\
			print(*(c+6));\
			print(*(c+7));\
			{\
				 int a=42;\
		  int b=24;\
		  int *p=&a;\
		  int *pb=&b;\
		  int **pp=&p;\
		  **pp=22;\
		  **pp=33;\
		  *p=44; \
		  print(**pp);\
		   *pp=&pb;\
		   **pp=123;\
		  print(b);\
				print(a);\
			}\
		  }";
char sffs[]="\
		  void main(){\
		  int a=42;\
		  int b=24;\
		  int *p=&a;\
		  int c[1];\
		  print(p);\
		  print(c);\
		  }";
char sds[]="\
		  void main(){\
		  char a='a';\
		  for(a='a';a<'z';a++)print(a);\
		  }";



	info i;
	char c;
		int m;
	pos p;

	i.mode=kvm;
	inittables(&i,ss,stack,&p);

	printf("\n");

	if(translation_unit(&p)) {
		printf(" ok\n");
		run(&i);
	}
	else{
		printf("\n%s",p.c);
	   printf("%s %s POS%s",i.err,i.errtoken,i.errpos);
	}
	printf("sdfsdfsdf\n");
	c=getchar();
	{
int u=0;
int i;
for(i=0;i<300;i++){u=i;//300 optimized factor 50 non opt
for(m=0;m < 10;++m) u+=fib3(1234567+m);
u-=i;
}
printf("%d\n%d",fib3(1234567),u);
	}
c=getchar();

	}

	return 0;
}
/*
// asmtest.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "iostream"
#include "windows.h"
using namespace std;
#define MOV(a,b) _asm _emit (a>>8)&0x00 _asm _emit b&0xff

#define mov_eax_(b) 

inline void NOP(){
	_asm _emit 0x90
}

#define aa bb
#undef aa
#define aa cc

int _tmain(int argc, _TCHAR* argv[])
{
goto jump3;
jump:	_asm ret;

jump2:	NOP();
jump3:
void *p;
_asm {

	lea eax,jump
	mov [p],eax
	
}
unsigned char *code= (unsigned char*)VirtualAlloc(NULL, 3, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

code[0]=144;
code[1]=144;
code[2]=195;
//[]={144,144,195};

//cout <<(int)((unsigned char*)(p))[0]<<endl;
//((unsigned char*)(p))[0]=0;

_asm call code 
	return 0;
}

*/
